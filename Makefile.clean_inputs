CONFIG_FILENAME=config

SUPPRESS_FLAG_ARTIFACTS=cleaned_ott/cleaned_ott.tre \
	cleaned_ott/cleaned_ott.json \
	cleaned_ott/ott_version.txt \
	cleaned_ott/cleaning_flags.txt

Makefile.clean_inputs: phylo_input/study_tree_pairs.txt

STUDY_TREE_STEM :=$(shell cat phylo_input/study_tree_pairs.txt)
STUDY_TREE_FN := $(addsuffix .json, $(STUDY_TREE_STEM))
STUDY_TREE_NEWICK := $(addsuffix .tre, $(STUDY_TREE_STEM))

ARTIFACTS += $(SUPPRESS_FLAG_ARTIFACTS) \
	phylo_snapshot/git_shas.txt \
	phylo_snapshot/concrete_rank_collection.json \
	cleaned_ott/cleaning_flags.txt \
	cleaned_ott/root_ott_id.txt \
	cleaned_phylo/cleaning_flags.txt \
	cleaned_phylo/root_ott_id.txt \
	cleaned_phylo/phylo_inputs_cleaned.txt \
	cleaned_phylo/needs_updating.txt \
	exemplified_phylo/taxonomy.tre \
	exemplified_phylo/args.txt \
	phylo_induced_taxonomy/taxonomy.tre \
	phylo_input/rank_collection.json

# default is "all"
all: $(ARTIFACTS)

clean:
	rm -f $(ARTIFACTS)
	rm -f cleaned_phylo/*.tre
	rm -f cleaned_phylo/*.json
	rm -f cleaned_phylo/needs_updating.txt
	rm -f exemplified_phylo/*.tre
	rm -f phylo_snapshot/*.json
	rm -f phylo_snapshot/git_shas.txt

# "cleaned_ott" has dubious taxa pruned off. should check against treemachine and smasher versions
cleaned_ott/root_ott_id.txt: $(CONFIG_FILENAME)
	./bin/config_checker.py --config=$(CONFIG_FILENAME) --property=synthesis.root_ott_id > cleaned_ott/.raw_root_ott_id.txt
	if ! diff cleaned_ott/.raw_root_ott_id.txt cleaned_ott/root_ott_id.txt 2>/dev/null; then mv cleaned_ott/.raw_root_ott_id.txt cleaned_ott/root_ott_id.txt ; fi

cleaned_ott/cleaning_flags.txt: $(CONFIG_FILENAME)
	./bin/config_checker.py --config=$(CONFIG_FILENAME) --property=taxonomy.cleaning_flags > cleaned_ott/.raw_cleaning_flags.txt
	if ! diff cleaned_ott/.raw_cleaning_flags.txt cleaned_ott/cleaning_flags.txt 2>/dev/null; then mv cleaned_ott/.raw_cleaning_flags.txt cleaned_ott/cleaning_flags.txt ; fi

cleaned_ott/ott_version.txt: $(OTT_DIR)/version.txt
	if ! diff $(OTT_DIR)/version.txt cleaned_ott/ott_version.txt >/dev/null 2>&1 ; then cp $(OTT_DIR)/version.txt cleaned_ott/ott_version.txt ; fi

cleaned_ott/cleaned_ott.tre: $(OTT_FILEPATHS) cleaned_ott/ott_version.txt cleaned_ott/cleaning_flags.txt cleaned_ott/root_ott_id.txt
	$(PEYOTL_ROOT)/scripts/ott/suppress_by_flag.py \
	    --ott-dir=$(OTT_DIR) \
	    --output=cleaned_ott/cleaned_ott.tre \
	    --log=cleaned_ott/cleaned_ott.json \
	    --flags="$(shell cat cleaned_ott/cleaning_flags.txt)" \
	    --root="$(shell cat cleaned_ott/root_ott_id.txt)"
#    Maybe replace python program with C++ program below after we can generate the necessary log files.
#	otc-taxonomy-parser $(OTT_DIR) --config=config -T > cleaned_ott/.raw_cleaned_ott.tre
#	mv cleaned_ott/.raw_cleaned_ott.tre cleaned_ott/cleaned_ott.tre

cleaned_ott/cleaned_ott.json: cleaned_ott/cleaned_ott.tre

# phylo_input holds the lists of study+tree pairs to be used during the supertree construction
#phylo_input/rank_collection.json:
#	echo '***TEMPORARY WORKAROUND***!!!!'
#	curl -o phylo_input/rank_collection.json http://phylo.bio.ku.edu/ot/synthesis-collection.json

phylo_input/studies.txt: phylo_input/rank_collection.json
	$(PEYOTL_ROOT)/scripts/collection_export.py --export=studyID phylo_input/rank_collection.json >phylo_input/studies.txt

phylo_input/study_tree_pairs.txt: phylo_input/rank_collection.json
	$(PEYOTL_ROOT)/scripts/collection_export.py --export=studyID_treeID phylo_input/rank_collection.json >phylo_input/study_tree_pairs.txt

# Snapshots of the NexSON are more efficient to produce in bulk (hence the export of the entire
# collection as a part of the concrete_rank_collection target
phylo_snapshot/git_shas.txt:
	./bin/shard_shas.sh > .tmp_git_shas.txt
	if ! diff phylo_snapshot/git_shas.txt .tmp_git_shas.txt >/dev/null 2>&1 ; then mv .tmp_git_shas.txt phylo_snapshot/git_shas.txt ; else rm .tmp_git_shas.txt ; fi

phylo_snapshot/concrete_rank_collection.json: phylo_snapshot/git_shas.txt phylo_input/rank_collection.json
	$(PEYOTL_ROOT)/scripts/phylesystem/export_studies_from_collection.py \
	  --phylesystem-par=$(PHYLESYSTEM_ROOT)/shards \
	  --output-dir=phylo_snapshot \
	  phylo_input/rank_collection.json \
	  -v 2>&1 | tee phylo_snapshot/stdouterr.txt

# phylo_snapshot/pg_%.json:  phylo_snapshot/git_shas.txt phylo_snapshot/concrete_rank_collection.json
# 	$(PEYOTL_ROOT)/scripts/phylesystem/export_studies_from_collection.py \
# 	  --phylesystem-par=$(PHYLESYSTEM_ROOT)/shards \
# 	  --output-dir=phylo_snapshot \
# 	  --select="$(shell basename $@)" \
# 	  phylo_input/rank_collection.json \
# 	  -v 2>&1 | tee -a phylo_snapshot/stdouterr.txt

# phylo_snapshot/ot_%.json:  phylo_snapshot/git_shas.txt phylo_snapshot/concrete_rank_collection.json
# 	$(PEYOTL_ROOT)/scripts/phylesystem/export_studies_from_collection.py \
# 	  --phylesystem-par=$(PHYLESYSTEM_ROOT)/shards \
# 	  --output-dir=phylo_snapshot \
# 	  --select="$(shell basename $@)" \
# 	  phylo_input/rank_collection.json \
# 	  -v 2>&1 | tee -a phylo_snapshot/stdouterr.txt

cleaned_phylo/needs_updating.txt: phylo_input/study_tree_pairs.txt cleaned_ott/cleaning_flags.txt cleaned_ott/root_ott_id.txt
	if ! diff cleaned_ott/cleaning_flags.txt cleaned_phylo/cleaning_flags.txt >/dev/null 2>&1 && \
	   ! diff cleaned_ott/root_ott_id.txt cleaned_phylo/root_ott_id.txt >/dev/null 2>&1 ; \
	then \
		sed -e 's:\(.*\):phylo_snapshot/\1.json:' < phylo_input/study_tree_pairs.txt > cleaned_phylo/x ; \
		bin/convert-space-to-newline cleaned_phylo/x > cleaned_phylo/needs_updating.txt ;\
		rm -f cleaned_phylo/x ;\
	else \
		./bin/write-needs-updating cleaned_phylo $$(sed -e 's:\(.*\):phylo_snapshot/\1.json:' < phylo_input/study_tree_pairs.txt) > cleaned_phylo/needs_updating.txt ;\
	fi
	cp cleaned_ott/cleaning_flags.txt cleaned_phylo/cleaning_flags.txt
	cp cleaned_ott/root_ott_id.txt cleaned_phylo/root_ott_id.txt

# Could we make the cleaned_phylo/*.tre files depend on INDIVIDUAL phylo_snapshot/*.json files?
cleaned_phylo/phylo_inputs_cleaned.txt: cleaned_phylo/needs_updating.txt cleaned_ott/cleaning_flags.txt cleaned_ott/root_ott_id.txt phylo_snapshot/concrete_rank_collection.json 
	$(PEYOTL_ROOT)/scripts/nexson/prune_to_clean_mapped.py \
	  --ott-dir=$(OTT_DIR) \
	  --input-files-list=cleaned_phylo/needs_updating.txt \
	  --out-dir=cleaned_phylo \
	  --ott-prune-flags="$(shell cat cleaned_ott/cleaning_flags.txt)" \
	  --root="$(shell cat cleaned_ott/root_ott_id.txt)"
	touch cleaned_phylo/phylo_inputs_cleaned.txt

# cleaned_phylo/%.tre: phylo_snapshot/%.json cleaned_ott/cleaning_flags.txt
# 	$(PEYOTL_ROOT)/scripts/nexson/prune_to_clean_mapped.py \
# 	  --ott-dir=$(OTT_DIR) \
# 	  --out-dir=cleaned_phylo \
# 	  --ott-prune-flags="$(shell cat cleaned_ott/cleaning_flags.txt)" \
# 	  $<

exemplified_phylo/args.txt : phylo_input/study_tree_pairs.txt 
	sed -e 's:\(.*\):cleaned_phylo/\1.tre:' phylo_input/study_tree_pairs.txt > exemplified_phylo/args.txt

# Could we make the exemplified_phylo/*.tre files depend on INDIVIDUAL cleaned_phylo/*.tre files?
exemplified_phylo/nonempty_trees.txt : exemplified_phylo/args.txt cleaned_ott/cleaned_ott.tre cleaned_phylo/phylo_inputs_cleaned.txt
	otc-nonterminals-to-exemplars \
	  -eexemplified_phylo \
	  cleaned_ott/cleaned_ott.tre \
	  -fexemplified_phylo/args.txt \
	  -nexemplified_phylo/.nonempty_trees.txt && mv exemplified_phylo/.nonempty_trees.txt exemplified_phylo/nonempty_trees.txt

phylo_induced_taxonomy/taxonomy.tre : exemplified_phylo/taxonomy.tre
	ln -s ../exemplified_phylo/taxonomy.tre phylo_induced_taxonomy/taxonomy.tre

# phylo_input holds the lists of study+tree pairs to be used during the supertree construction
phylo_input/collections.txt: config
	bin/config_checker.py --config=config --property=synthesis.collections > phylo_input/.raw_collections.txt
	if ! diff phylo_input/collections.txt phylo_input/.raw_collections.txt 2>/dev/null ; then mv phylo_input/.raw_collections.txt phylo_input/collections.txt ; else rm phylo_input/.raw_collections.txt ; fi

phylo_input/rank_collection.json: phylo_input/collections.txt
	cd phylo_input ; \
	../bin/reaggregate-synth-collections.sh .raw_rank_collection.json
	if ! diff phylo_input/rank_collection.json phylo_input/.raw_rank_collection.json 2>/dev/null ; then mv phylo_input/.raw_rank_collection.json phylo_input/rank_collection.json ; else rm phylo_input/.raw_rank_collection.json ; fi
