#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass paper
\begin_preamble
\usepackage{algorithm,algpseudocode}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Title
\end_layout

\begin_layout Author
authors
\begin_inset Formula $^{1}$
\end_inset


\end_layout

\begin_layout Abstract
We present a new software pipeline for constructing a summary supertree
 from a taxonomy and a collection of curated phylogenetic inputs.
 This pipeline is made up of the software packages 
\emph on
propinquity
\emph default
, 
\emph on
otcetera
\emph default
, and 
\emph on
peyotl
\emph default
.
 It is free software and is available from github.
 The pipeline improves on previous supertree construction methods in that
 it satisfies the criteria of having no unsupported branches, and no unnecessary
 polytomies.
 The reason for the inclusion and exclusion of each edge is made transparent
 by an annotations file that we compute
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is maybe not exactly true, yet.
 But the branches that support an include edge are available.
 
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We could try to compute clearer reasons for edge non-inclusion: we could
 determine which summary edges conflict, and report all input edges that
 support conflicting edges.
 We could check which supporting input edges conflict with the excluded
 edge.
\end_layout

\end_inset

.
 The supertree increases the number of phylogenetic input splits that are
 displayed, while decreasing the number of conflicts between the summary
 tree and the phylogenetic inputs.
 The 
\emph on
propinquity
\emph default
 pipeline decreases the amount of computer memory and processing time required
 to construct the synthesis tree by about x-fold
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here we need to know how long the old pipeline took.
\end_layout

\end_inset

.
 This prepares the way for the inclusion of many more input trees.
 
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Open Tree of Life project seeks to build a platform for summarizing
 what is known about phylogenetic relationships across all of Life.
 This summary consists of a supertree that transparently and justifiably
 represents phylogenetic information from a collection of curated phylogenetic
 input trees along with a taxonomy tree.
 The taxonomy tree has complete coverage of all leaf taxa that we are working
 with.
 The taxonomy tree is provided by the OpenTree Taxonomy.
 In contrast, the phylogenetic inputs need not include all leaf taxa.
 Input trees are sourced from phylogenies on publications with DOI numbers.
 We assume that the taxonomy and input trees are rooted, and our supertree
 is also rooted.
\end_layout

\begin_layout Standard
We describe a software pipeline (propinquity) that summarizes and integrates
 these smaller source trees and the taxonomy tree into a single supertree.
 This software pipeline combines tools for manipulating and solving supertrees
 and supertree subproblems (otcetera).
\end_layout

\begin_layout Paragraph
Goals
\end_layout

\begin_layout Standard
We seek to build a summary supertree that represents its source trees in
 an transparent and justifiable fashion.
 In order to accomplish transparency and justification, our pipeline also
 produces an annotations file that relates each supertree edge to the input
 tree edges that support it.
 To aid in interpretation of the supertree, we require that each supertree
 edge be supported by at least one input tree edge.
 In addition to aiding interpretability, this requirement keeps the supertree
 from arbitrarily representing information that comes from none of the input
 trees.
 Likewise, we require that the supertree have no unnecessary polytomies.
 Thus, for each input edge that is 
\emph on
not
\emph default
 included, we can point to a reason for non-inclusion by showing that the
 input edge conflicts with some node/edge of the summary tree.
 We also seek to include all taxa from the taxonomy in the supertree.
 These optimality criteria help to define what it means for the supertree
 to represent the input trees, as well as justifying and explaining why
 various features of the supertree exist.
 
\end_layout

\begin_layout Standard
One of our aims in supertree construction is to minimize the amount of informati
on in the supertree that does not come from single input trees.
 In general, we permit information that comes not from any individual input
 tree, but comes from combinations of input trees.
 However, we seek to exclude information that comes from none of the input
 trees.
 This motivates the criterion of not having any unsupported edges, since
 these edges could be removed without decreasing the support from any input
 tree.
\end_layout

\begin_layout Standard
We note here that while our supertree satisfies these optimality criteria,
 there is not necessarily a 
\emph on
unique
\emph default
 optimum.
 We also seek to construct a supertree that represents as many input tree
 edges as possible.
 Since non-included input tree edges must conflict with the supertree (or
 they would have been added), this criterion is the same as minimizing the
 number of input edges that conflict with the taxonomy.
\end_layout

\begin_layout Paragraph
Approach
\end_layout

\begin_layout Standard
Any approach to supertree construction must deal with the need to adjudicate
 between conflicting input trees.
 We choose to deal with conflict by ranking the input trees, and preferring
 to include edges from higher-ranked trees.
 Ranking is perhaps questionable because it does not mediate conflicts based
 on the relative amount of evidence for each alternative.
 However, it is a reasonable starting point.
 This is because it has the benefits of making it easy to see why some groups
 are included or not (transparency), and because it allows simpler and cleaner
 algorithms.
 However, we note that if an edge 
\begin_inset Formula $c$
\end_inset

 conflicts with a higher-ranked edge 
\begin_inset Formula $b$
\end_inset

, then 
\begin_inset Formula $b$
\end_inset

 may still be included in the supertree.
 This can occur when the higher ranked edge 
\begin_inset Formula $b$
\end_inset

 conflicts with a yet-higher ranked edge 
\begin_inset Formula $a$
\end_inset

, and thus 
\begin_inset Formula $b$
\end_inset

 is not included.
 In that case, it will be possible for 
\begin_inset Formula $e$
\end_inset

 to be represented in the summary tree.
 
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Example (#2):
\end_layout

\begin_layout Itemize
tree1 has 
\begin_inset Formula $((a_{1},b),(c,d))$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha=a_{1}b|c\,\bullet$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tree2 has 
\begin_inset Formula $((a_{1},c),(b,d))$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\beta=a_{1}c|b\,\bullet$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tree3 has 
\begin_inset Formula $(((a_{1},a_{2}),a_{3}),b,c)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\gamma=a_{1}a_{2}|a_{3}bc\,\bullet$
\end_inset


\end_layout

\begin_layout Plain Layout
Here 
\begin_inset Formula $\beta$
\end_inset

 conflict with 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\gamma$
\end_inset

 conflicts with 
\begin_inset Formula $\alpha$
\end_inset

.
 Although actually 
\begin_inset Formula $\gamma\implies\alpha$
\end_inset

, since you can get 
\begin_inset Formula $\alpha$
\end_inset

 from 
\begin_inset Formula $\gamma$
\end_inset

 by merely removing taxa.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
In order to produce a comprehensive supertree, we also require that the
 ranked list of input trees contain a rooted taxonomy tree.
 Unlike other input trees, this tree is require to contain all taxa, and
 thus has the maximal leaf set.
 We make the taxonomy tree the lowest ranked tree.
 This new formulation is the formulation of the 
\begin_inset Quotes eld
\end_inset

taxonomic supertree problem
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In our current formulation, the taxonomy tree is also unique in that the
 taxonomy is the only source of taxonomic names.
 Each node in the taxonomy tree corresponds to a named group.
 Taxonomic groups are identified in the summary supertree by finding a branch
 (or 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

) that has exactly the same include|exclude relationship.
 In keeping with this, the taxonomy supertree can meaningfully possess degree-tw
o nodes.
 Although these nodes can be removed without affecting the relationships
 of the leaves, they do represent nested taxonomic groups that contain exactly
 one subgroup, such as 
\series bold
example
\series default
.
 
\end_layout

\begin_layout Standard
The taxonomy is used to determine which tips are terminal taxa.
\end_layout

\begin_layout Subsection
Non-terminals as tips
\end_layout

\begin_layout Standard
Many input trees have tips that are not terminal taxa, but higher order
 taxonomic groups.
 We seek to transform these input trees into a standardized form with no
 non-terminal tips by adding or replacing nodes with their terminal descendant
 taxa.
 One approach would be to simply determine all descendant terminal taxa
 and attach them as children of the problematic tip.
 However, this changes the nonterminal tip into the parent of a clade that
 represents a claim of monophyly for the taxon.
\end_layout

\begin_layout Standard
This might well not be the case.
 Often in such cases a single exemplar of the nonterminal taxon was used
 as a tip, and we don't know which one this was.
 Our approach to this problem is to transform the input tree by instead
 attaching all descendant tips to the parent of the nonterminal tip, and
 removing the nonterminal tip.
 Thus, if 
\begin_inset Formula $A$
\end_inset

 is a non-terminal taxon containing terminal descendants 
\begin_inset Formula $a_{1}$
\end_inset

and 
\begin_inset Formula $a_{2}$
\end_inset

, we would replace the clade 
\begin_inset Formula $(A,b,c)$
\end_inset

 with 
\begin_inset Formula $(a_{1},a_{2},b,c)$
\end_inset

 instead of the clade 
\begin_inset Formula $((a_{1},a_{2})A,b_{1},b_{2})$
\end_inset

.
\end_layout

\begin_layout Section
Algorithmic approach
\end_layout

\begin_layout Standard
In order to make the supertree construction more tractable, we prune the
 taxonomy by removing tips that are not present in any input tree, on the
 theory that these tips cannot affect conflict resolution, and can easily
 be added-back after the supertree problem is solved.
\end_layout

\begin_layout Standard
We also take a divide-and-conquer approach by dividing the supertree into
 subproblems along edges of the taxonomy that are uncontested by any of
 the input trees.
 This approach therefore forces monophyly for these groups, which might
 (possibly?) be non-optimal.
 However, the downsides of this approach seem minimal, compared to the improveme
nt in scalability.
 We thus divide the supertree problem into 
\begin_inset Quotes eld
\end_inset

subproblems
\begin_inset Quotes erd
\end_inset

, and apply our solver to each subproblem.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Presenting an easy-to-interpret summary of trees that have been “curated”
 is one component of that effort.
 We seek to find a summary tree that
\end_layout

\begin_layout Enumerate

\series bold
minimizes 
\series default
the amount of computer memory and processing time required to construct
 the summary.
\end_layout

\begin_layout Enumerate

\series bold
maximizes
\series default
 the number of splits in input trees that it displays.
 
\end_layout

\begin_layout Enumerate
(?)
\series bold
 minimize
\series default
 the number of conflicts between the summary tree and the input trees (?)
\end_layout

\begin_layout Enumerate

\series bold
has no unsupported branches:
\series default
 each non-terminal branch is supported by an input tree.
\end_layout

\begin_layout Enumerate

\series bold
has no unnecessary polytomies:
\series default
 polytomies should remain in the supertree only if unresolvable by any of
 the input trees.
\end_layout

\begin_layout Plain Layout
The point of maximizing the number of displayed groups from input trees,
 and having no unsupported branches, is not to construct an estimate of
 the true tree, but to explain and represent the input trees well.
 Thus, the tree should be interpreted as a summary.
 Here a non-terminal branch is 
\begin_inset Quotes eld
\end_inset

supported
\begin_inset Quotes erd
\end_inset

 by a phylogenetic input if contracting that branch stops displaying a split
 from that phylogenetic input.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Algorithmic approach
\end_layout

\begin_layout Standard
We also make the following tactical choices
\end_layout

\begin_layout Enumerate

\series bold
conflict
\series default
 is resolved by ranking the input trees; splits from higher ranked trees
 over-rule conflicting splits from lower-ranked trees, unless the split
 from the higher-ranked tree is itself over-ruled by a split from an even
 high ranked tree.
\end_layout

\begin_layout Enumerate
a 
\series bold
taxonomy-based supertree
\series default
.
 This is a novel name for a special form of the supertree problem.
 A taxonomy-based supertree has at least one input (the taxonomic tree)
 which is complete.
 the taxonomy is considered the lowest-ranked input.
\end_layout

\begin_layout Standard
In order to achieve these goals, we have made the following algorithmic
 choices:
\end_layout

\begin_layout Subsection
Problem decomposition
\end_layout

\begin_layout Standard
First, all branches in the taxonomy that are not contested by any of the
 input trees are automatically accepted into the summary tree.
 Given these branches, the supertree problem may then be decomposed into
 smaller problems delimited by the uncontested taxonomy branches as boundaries.
 Each sub-problem is characterized by a ranked sequence of subtrees that
 are derived from regions of phylogenetic inputs that fall between the boundarie
s.
 The smaller problems size then makes tractable a variety of strategies
 to solve the sub-problems, and decreases the amount of computer memory
 and processing time that is required.
 
\end_layout

\begin_layout Subsection
Subproblem solution
\end_layout

\begin_layout Standard
Second, when solving sub-problems, we sequentially incorporate splits from
 trees in order of ranking, retaining splits that are compatible with the
 current set of splits.
 The order of splits from the same tree is not specified by this approach,
 and we incorporate splits in post-order.
 We make use of the BUILD algorithm to assess compatibility.
 This strategy avoids unnecessary polytomies, since splits of later input
 trees are only rejected from the summary supertree if they conflict with
 higher-priority splits.
 Finally, we use the BUILD algorithm to construct a supertree displaying
 all of the splits in the set of compatible splits.
 Using the BUILD algorithm to construct the subproblem summary tree satisfies
 criterion 3, because trees from the BUILD algorithm do not contain unsupported
 branches.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require An ordered list of $M$ splits, $
\backslash
mathcal{R} = [R_1, R_2, R_3, 
\backslash
ldots, R3, 
\backslash
ldots, R_M]$
\end_layout

\begin_layout Plain Layout


\backslash
State $
\backslash
mathcal{C} = [R_1]$
\end_layout

\begin_layout Plain Layout


\backslash
For{each split $i$ in $[2, 3 
\backslash
ldots M]$}
\end_layout

\begin_layout Plain Layout

   
\backslash
State $
\backslash
mathcal{T} 
\backslash
leftarrow 
\backslash
mathcal{C} + R_i$ 
\backslash
Comment{where `+' means concatenating 2 lists}
\end_layout

\begin_layout Plain Layout

   
\backslash
If{
\backslash
textsc{BUILD}$(
\backslash
mathcal{T})$ does not return null}
\end_layout

\begin_layout Plain Layout

      
\backslash
State $
\backslash
mathcal{C} 
\backslash
leftarrow 
\backslash
mathcal{T}$
\end_layout

\begin_layout Plain Layout

   
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor{}
\end_layout

\begin_layout Plain Layout


\backslash
State
\backslash
Return $
\backslash
mathcal{C}$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ConsistentSplitsFromRankedList"

\end_inset

ConsistentSplitsFromRankedList
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Pipeline
\end_layout

\begin_layout Standard
In order to achieve these criteria, we have 
\end_layout

\begin_layout Enumerate
Start with ranked list of trees
\end_layout

\begin_layout Enumerate
Check out phylo inputs from phylesystem
\end_layout

\begin_layout Enumerate
Make phylo input snapshot (e.g.
 pinned version of phylo inputs)
\end_layout

\begin_layout Enumerate
clean taxonomy & clean phylo inputs (in parallel)
\end_layout

\begin_layout Enumerate
Replace non-terminals with exemplars
\end_layout

\begin_layout Enumerate
Decompose into subproblems
\end_layout

\begin_layout Enumerate
Solve subproblems
\end_layout

\begin_layout Enumerate
Regraft subproblems
\end_layout

\begin_layout Enumerate
Unprune the solution
\end_layout

\begin_layout Enumerate
Label the solution
\end_layout

\begin_layout Enumerate
Generate annotations
\end_layout

\begin_layout Standard
import READMEs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pipeline-tools.png
	height 75pheight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Data flow through the 
\emph on
propinquity
\emph default
 pipeline.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Export trees from collections
\end_layout

\begin_layout Standard
The ranked list of trees is specified as an ordered list of 
\begin_inset Quotes eld
\end_inset

collections
\begin_inset Quotes erd
\end_inset

.
 A collection is an ordered list of trees that is versioned using 
\emph on
git.

\emph default
 The ranked list of trees used in synthesis is obtained simply by concatenating
 the collections in order.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: List of collections 
\begin_inset Formula $\mathcal{C}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: List of trees 
\begin_inset Formula $\mathcal{T}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Implementation: 
\emph on
collection_export.py
\emph default
 from peyotl gets (study,tree) pairs
\end_layout

\begin_layout Subsection
Prune the reference taxonomy
\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: Not all taxa in OTT are reliable enough to belong in the summary tree.
 The reference taxonomy producing software flags taxa in several ways (which
 are listed here TODO: we still need real documentation of the flagging
 system).
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: “raw” reference taxonomy with flags produced by https://github.com/OpenTre
eOfLife/ reference-taxonomy 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: 
\begin_inset Formula $\mathbb{T}$
\end_inset

, the complete taxonomy for synthesis with some taxa pruned.
 This will determine the leaf label set of the final summary tree.
 
\end_layout

\begin_layout Enumerate
Current Impl.
 now performed by 
\emph on
suppress-by-flag.py
\emph default
 from 
\emph on
peyotl
\emph default
 
\end_layout

\begin_layout Enumerate
Documentation needed on which flags are pruned and why.
 
\end_layout

\begin_layout Enumerate
We should serve this tree somewhere as it is a crucial input for the rest
 of the pipeline.
\end_layout

\begin_layout Subsection
Snapshot input studies
\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: For a make-based system it would be useful to copy the incoming otNexSON
 files to a snapshot location if they differ from the version of that study
 that is already found in that staging location.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: local copy of phylesystem git repo, list of trees (study+tree ID
 + optional git SHA) to be used 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: (1) copies of the otNexSON files from the specified SHA.
 (2) record of tree identifiers 
\end_layout

\begin_layout Standard
Current Impl.: None - similar operation done by gcmdr.
 TODO for Impl.: Flat file implementation needed URL for output: None
\end_layout

\begin_layout Subsection
Snapshot input trees
\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: The study files may contain multiple trees, for a make-base system it
 would be good to have a timestamped file for each tree 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: snapshot of otNexSON from previous step.
 list of tree identifiers.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: (1) one otNexSON for each tree.
 The current naming conven- tion of studyID treeID.nexson could be used -
 there is no need to support multiple git-SHAs per tree.
 
\end_layout

\begin_layout Standard
Current Impl.: None - similar operation done by gcmdr.
 TODO for Impl.: Flat file implementation needed URL for output: None
\end_layout

\begin_layout Subsection
Pruning of input trees
\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: To improve the chance of having a correct rooting, we prune the trees
 to just the ingroup.
 We also prune the tree down such that they contain no more than 1 exemplar
 of any terminal taxon and there are no cases of the taxon for one tip containin
g the taxon mapped to another tip.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: snapshot of otNexSON trees from previous step.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: (1) 
\begin_inset Formula $\mathcal{T}$
\end_inset

, the input set of tree represented as one newick tree for each input tree
 with internal node labels that correspond to the node ID in the otNexSON
 of the MRCA node.
 (2) a record of the pruning edits performed.
 
\end_layout

\begin_layout Standard
Current Impl.: None - similar operation done by gcmdr.
 TODO for Impl.: (1) Flat file implementation needed.
 (2) record of edits needed.
 (3) identifiers for the internal nodes would be nice for reporting the
 provenance of edges in the summary tree.
 (4) We should serve these trees somewhere as they are crucial inputs for
 the rest of the pipeline.
\end_layout

\begin_layout Subsection
Expand tips mapped to non-terminal taxa
\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: As explained in section 1.6.2 (of otcetera doc), expanding tips that are
 mapped to non-terminal taxa to the full set of their terminal descendants
 and attaching these tips to the parent of the taxon should generate a tree
 that correctly represents what the input tree says (without erroneously
 claiming that the tree supports monophyly).
 A clever implementation would note whether a descendant terminal taxon
 occurs in other trees in the T corpus.
 If there are multiple terminal descendant taxa in the expansion that only
 occur in the taxonomy, then it should be fine to let the expansions just
 contain 1 of these tips, 
\begin_inset Formula $x$
\end_inset

.
 This would mean that the others are pruned in the next step, but will be
 placed in the correct spot in the final summary tree because they should
 attach at the same parent node as the single exemplar, 
\begin_inset Formula $x$
\end_inset

.
 Failing to take this optimization will only mean that the pruned taxonomy
 is too large.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: 
\begin_inset Formula $\mathbb{T}$
\end_inset

 and 
\begin_inset Formula $\mathcal{T}$
\end_inset

 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: 
\begin_inset Formula $\mathcal{T}_{E}$
\end_inset

 – the set of phylogenetic inputs expanded such that no leaf is mapped to
 a non-terminal taxon.
 
\end_layout

\begin_layout Standard
Current Impl.: None.
 
\end_layout

\begin_layout Standard
TODO for Impl.:TODO: write this URL for output: 
\end_layout

\begin_layout Itemize
We should probably post this set of trees, as many tools don’t deal with
 tips that are mapped to non-terminal taxa.
 So these trees may be the most accessible set of inputs for most interested
 parties.
\end_layout

\begin_layout Subsection
Prune taxonomy down to tips represented in 
\begin_inset Formula $\mathcal{T}_{E}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Explanation
\emph default
: This is just an optimization step.
 Each terminal taxon that is only found in T, can be placed on the final
 summary tree by creating a tree for the overlapping taxonomic inputs and
 then grafting on the “taxonomy only” lineages.
 This pruning makes the inputs for the subsequent steps smaller 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: T and T E 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: T P the pruned taxonomy 
\end_layout

\begin_layout Standard
Current Impl.: otc-prune-taxonomy can perform this TODO for Impl.: URL for
 output: may want to post this somewhere.
\end_layout

\begin_layout Subsection
Decompose the inputs into subproblems of uncontested taxa 
\end_layout

\begin_layout Standard

\emph on
Explanation:
\emph default
 The decision to force uncontested taxa in the final summary means that
 we can separate the problems into non-overlapping subproblems.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: 
\begin_inset Formula $\mathbb{T}_{P}$
\end_inset

 and 
\begin_inset Formula $\mathcal{T}_{E}$
\end_inset

 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: subproblems.
 
\end_layout

\begin_layout Standard
Currently expressed (1) as one newick tree file per subproblem with the
 name SUBPROBLEMID.tre, and (2) a file called SUBPROBLEMID-tree-names.txt
 with a treefile name on each line or “TAX- ONOMY” indicating the source
 of each tree.
 the SUBPROBLEMID is ‘ott’ followed by the OTT ID.
 Current Impl.: otc-uncontested-decompose TODO for Impl.: URL for output:
 http://phylo.bio.ku.edu/ot/export-sub-temp.tar.gz has a snapshot, but those
 subproblems were not produced with the non-terminal tips expanded to terminals
 so there is some wonkiness - such tips are pruned if the taxon is contested,
 but their ID sets still affect the embedding of the deeper nodes in the
 tree.
 This needs to be rerun after step 2.5 is completed.
\end_layout

\begin_layout Subsection
Simplify Subproblems
\end_layout

\begin_layout Standard

\emph on
Explanation:
\emph default
 As (to be) described in section 1.9 there are several operations that can
 be per- formed that will reduce the size of the subproblems but which should
 not compromise our ability to obtain the same subproblem solution.
 Many subproblems are trivially solvable, so the tool that does this will
 also be a crude solver.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: The set of subproblems, a simplified-problems direc- tory, and a
 solutions directory 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: When possible, subproblem solutions and simplifications will be
 written to the 2 output directories.
\end_layout

\begin_layout Standard
Current Impl.: an implementation is started, but far from complete in the
 supertree branch of peyotl TODO for Impl.:TODO: finish URL for output:
\end_layout

\begin_layout Subsection
Solve subproblems (old - merge w/ below)
\end_layout

\begin_layout Standard

\emph on
Explanation:
\emph default
 Attempt to find an admissible summary tree for the set of summaries that
 are the Maximum Sum of Weighted Input Phylogenetic Statements Displayed
 set.
 We probably want (1) a brute force implementation that we can use for small
 subproblems so we do not have to worry about errors from finding local
 optima, and (2) one or more heuristics.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Input: a “raw” subproblem from step 2.7 or a simplified subproblem from step
 2.8.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Output: a tree for each subproblem - stored in a solutions dir under the
 name SUBPROBLEMID.tre Current Impl.: treemachine may provide one solver.
 
\end_layout

\begin_layout Standard
TODO for Impl.: exact impl and, perhaps we need another approximate solver
 URL for output:
\end_layout

\begin_layout Subsection
Solve subproblems (new - merge w/ above)
\end_layout

\begin_layout Standard
For the sub-problem solver, we make iterative use of the BUILD algorithm.
 We process input trees in order of their priority.
 We use the BUILD algorithm to determine whether a given split in an input
 tree is consistent with the splits we have kept so far.
 If the new split is consistent, then we add it to the set.
 After considering all input trees, and the taxonomy, we use the BUILD algorithm
 to construct a tree from the set of consistent splits.
\end_layout

\begin_layout Itemize
Add algorithm from TEX document.
\end_layout

\begin_layout Subsection
Collapse unsupported nodes -- stopped here copying from otcetera doc.
\end_layout

\begin_layout Section
Example
\end_layout

\begin_layout Standard
We should have a small example: taxonomy and a couple of trees.
 I guess the example should illustrate the idea of uncontested decomposition?
 Maybe about 8 taxa, 1 contested node, 1 uncontested node?
\end_layout

\begin_layout Standard
We could also have an example thats 
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
We have decreased the time to construct a supertree from (?) about 24 hours
 to about 8 minutes (minus pickle-creation time).
 The amount of RAM required to construct the supertree has decreased from
 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $Y$
\end_inset

.
 
\end_layout

\begin_layout Standard
Compared to the previous pipeline, we have
\end_layout

\begin_layout Itemize
no unsupported nodes
\end_layout

\begin_layout Itemize
no unresolved polytomies
\end_layout

\begin_layout Standard
We also increase the number of displayed input splits from 35439 to 39713,
 which is an increase of 3774 more nodes displayed, a 10.6% increase.
 The number of input splits that do not conflict with the summary tree,
 but are not incorporated drops from 2736 to 0.
 The number of input splits that conflict with the phylogeny drops from
 2850 to 1312, a decrease of 1538, or 54.0%.
\end_layout

\begin_layout Standard
Additionally, our pipeline now produces a tree with annotations about which
 input trees support each node in the summary tree.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
One of our aim in supertree construction is to minimize the amount of informatio
n in the supertree that does not come from any of the input trees.
 However this general principle can be formalized in a variety of ways.
 For example, one approach is to minimize the number of nodes in the supertree
 while representing as many of the input splits as possible.
 While initially attractive, this approach has the downside that, when it
 is given two input trees with disjoint taxa, it will attempt to merge these
 trees into a single tree in order to decrease the number of nodes.
 For example, if given the tree ((human,gorilla),(dog,cat)) and the tree
 ((fugu,tuna),(shark,ray)) the minimum node criterion leads to the supertree
 ((human,gorilla,fugu,tuna),(dog,cat,shark,ray)) or ((human,gorilla,shark,ray),(
dog,cat,fugu,tuna)) with 3 internal nodes.
 In constrast, the BUILD algorithm would produce ((human,gorilla),(dog,cat),(fug
u,tuna),(shark,ray)) with 5 internal nodes.
 We thus prefer the BUILD algorithm, with its preference not to merge groups
 unless there is phylogenetic input supporting the merger.
\end_layout

\begin_layout Paragraph*
comparison with other supertree approaches
\end_layout

\begin_layout Standard
distance-based: what supertree approaches are distance-based?
\end_layout

\begin_layout Standard
maximum number of input triplets
\end_layout

\begin_layout Paragraph*
guarantees
\end_layout

\begin_layout Itemize
may not display a rooted triplet that is supported and uncontested, if that
 triplet is contested by a 
\emph on
combination
\emph default
 of other rooted triplets.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "otcetera"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
