#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass paper
\begin_preamble
\usepackage{algorithm,algpseudocode}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Title
\end_layout

\begin_layout Author
authors
\begin_inset Formula $^{1}$
\end_inset


\end_layout

\begin_layout Abstract
We present a new software pipeline for constructing a summary supertree
 from a taxonomy and a collection of curated phylogenetic inputs.
 This pipeline is made up of the software packages 
\emph on
propinquity
\emph default
, 
\emph on
otcetera
\emph default
, and 
\emph on
peyotl
\emph default
.
 It is free software and is available from github.
 The pipeline improves on previous supertree construction methods in that
 it satisfies the criteria of having no unsupported branches, and no unnecessary
 polytomies.
 The reason for the inclusion and exclusion of each edge is made transparent
 by an annotations file that we compute
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is maybe not exactly true, yet.
 But the branches that support an include edge are available.
 
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We could try to compute clearer reasons for edge non-inclusion: we could
 determine which summary edges conflict, and report all input edges that
 support conflicting edges.
 We could check which supporting input edges conflict with the excluded
 edge.
\end_layout

\end_inset

.
 The supertree increases the number of phylogenetic input splits that are
 displayed, while decreasing the number of conflicts between the summary
 tree and the phylogenetic inputs.
 The 
\emph on
propinquity
\emph default
 pipeline decreases the amount of computer memory and processing time required
 to construct the synthesis tree by about x-fold
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here we need to know how long the old pipeline took.
\end_layout

\end_inset

.
 This prepares the way for the inclusion of many more input trees.
 
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Open Tree of Life project seeks to build a platform for summarizing
 what is known about phylogenetic relationships across all of Life.
 This summary consists of a supertree that transparently and justifiably
 represents phylogenetic information from a collection of curated phylogenetic
 input trees along with a taxonomy tree.
 The taxonomy tree has complete coverage of all leaf taxa that we are working
 with.
 The taxonomy tree is provided by the OpenTree Taxonomy.
 In contrast, the phylogenetic inputs need not include all leaf taxa.
 Input trees are sourced from phylogenies on publications with DOI numbers.
 We assume that the taxonomy and input trees are rooted, and our supertree
 is also rooted.
\end_layout

\begin_layout Standard
We describe a software pipeline (propinquity) that summarizes and integrates
 these smaller source trees and the taxonomy tree into a single supertree.
 This software pipeline combines tools for manipulating and solving supertrees
 and supertree subproblems (otcetera).
\end_layout

\begin_layout Paragraph
Goals
\end_layout

\begin_layout Standard
We seek to build a summary supertree that represents its source trees in
 an transparent and justifiable fashion.
 In order to accomplish transparency and justification, our pipeline also
 produces an annotations file that relates each supertree edge to the input
 tree edges that support it.
 To aid in interpretation of the supertree, we require that each supertree
 edge be supported by at least one input tree edge.
 In addition to aiding interpretability, this requirement keeps the supertree
 from arbitrarily representing information that comes from none of the input
 trees.
 Likewise, we require that the supertree have no unnecessary polytomies.
 Thus, for each input edge that is 
\emph on
not
\emph default
 included, we can point to a reason for non-inclusion by showing that the
 input edge conflicts with some node/edge of the summary tree.
 We also seek to include all taxa from the taxonomy in the supertree.
 These optimality criteria help to define what it means for the supertree
 to represent the input trees, as well as justifying and explaining why
 various features of the supertree exist.
 
\end_layout

\begin_layout Standard
One of our aims in supertree construction is to minimize the amount of informati
on in the supertree that does not come from single input trees.
 In general, we permit information that comes not from any individual input
 tree, but comes from combinations of input trees.
 However, we seek to exclude information that comes from none of the input
 trees.
 This motivates the criterion of not having any unsupported edges, since
 these edges could be removed without decreasing the support from any input
 tree.
\end_layout

\begin_layout Standard
We note here that while our supertree satisfies these optimality criteria,
 there is not necessarily a 
\emph on
unique
\emph default
 optimum.
 We also seek to construct a supertree that represents as many input tree
 edges as possible.
 Since non-included input tree edges must conflict with the supertree (or
 they would have been added), this criterion is the same as minimizing the
 number of input edges that conflict with the taxonomy.
\end_layout

\begin_layout Paragraph
Approach
\end_layout

\begin_layout Standard
Any approach to supertree construction must deal with the need to adjudicate
 between conflicting input trees.
 We choose to deal with conflict by ranking the input trees, and preferring
 to include edges from higher-ranked trees.
 Ranking is perhaps questionable because it does not mediate conflicts based
 on the relative amount of evidence for each alternative.
 However, it is a reasonable starting point.
 This is because it has the benefits of making it easy to see why some groups
 are included or not (transparency), and because it allows simpler and cleaner
 algorithms.
 However, we note that if an edge 
\begin_inset Formula $c$
\end_inset

 conflicts with a higher-ranked edge 
\begin_inset Formula $b$
\end_inset

, then 
\begin_inset Formula $b$
\end_inset

 may still be included in the supertree.
 This can occur when the higher ranked edge 
\begin_inset Formula $b$
\end_inset

 conflicts with a yet-higher ranked edge 
\begin_inset Formula $a$
\end_inset

, and thus 
\begin_inset Formula $b$
\end_inset

 is not included.
 In that case, it will be possible for 
\begin_inset Formula $e$
\end_inset

 to be represented in the summary tree.
 
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Example (#2):
\end_layout

\begin_layout Itemize
tree1 has 
\begin_inset Formula $((a_{1},b),(c,d))$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha=a_{1}b|c\,\bullet$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tree2 has 
\begin_inset Formula $((a_{1},c),(b,d))$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\beta=a_{1}c|b\,\bullet$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tree3 has 
\begin_inset Formula $(((a_{1},a_{2}),a_{3}),b,c)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\gamma=a_{1}a_{2}|a_{3}bc\,\bullet$
\end_inset


\end_layout

\begin_layout Plain Layout
Here 
\begin_inset Formula $\beta$
\end_inset

 conflict with 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\gamma$
\end_inset

 conflicts with 
\begin_inset Formula $\alpha$
\end_inset

.
 Although actually 
\begin_inset Formula $\gamma\implies\alpha$
\end_inset

, since you can get 
\begin_inset Formula $\alpha$
\end_inset

 from 
\begin_inset Formula $\gamma$
\end_inset

 by merely removing taxa.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
In order to produce a comprehensive supertree, we also require that the
 ranked list of input trees contain a rooted taxonomy tree.
 Unlike other input trees, this tree is require to contain all taxa, and
 thus has the maximal leaf set.
 We make the taxonomy tree the lowest ranked tree.
 This new formulation is the formulation of the 
\begin_inset Quotes eld
\end_inset

taxonomic supertree problem
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In our current formulation, the taxonomy tree is also unique in that the
 taxonomy is the only source of taxonomic names.
 Each node in the taxonomy tree corresponds to a named group.
 Taxonomic groups are identified in the summary supertree by finding a branch
 (or 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

) that has exactly the same include|exclude relationship.
 In keeping with this, the taxonomy supertree can meaningfully possess degree-tw
o nodes.
 Although these nodes can be removed without affecting the relationships
 of the leaves, they do represent nested taxonomic groups that contain exactly
 one subgroup, such as 
\series bold
example
\series default
.
 
\end_layout

\begin_layout Standard
The taxonomy is used to determine which tips are terminal taxa.
\end_layout

\begin_layout Subsection
Non-terminals as tips
\end_layout

\begin_layout Standard
Many input trees have tips that are not terminal taxa, but higher order
 taxonomic groups.
 We seek to transform these input trees into a standardized form with no
 non-terminal tips by adding or replacing nodes with their terminal descendant
 taxa.
 One approach would be to simply determine all descendant terminal taxa
 and attach them as children of the problematic tip.
 However, this changes the nonterminal tip into the parent of a clade that
 represents a claim of monophyly for the taxon.
\end_layout

\begin_layout Standard
This might well not be the case.
 Often in such cases a single exemplar of the nonterminal taxon was used
 as a tip, and we don't know which one this was.
 Our approach to this problem is to transform the input tree by instead
 attaching all descendant tips to the parent of the nonterminal tip, and
 removing the nonterminal tip.
 Thus, if 
\begin_inset Formula $A$
\end_inset

 is a non-terminal taxon containing terminal descendants 
\begin_inset Formula $a_{1}$
\end_inset

and 
\begin_inset Formula $a_{2}$
\end_inset

, we would replace the clade 
\begin_inset Formula $(A,b,c)$
\end_inset

 with 
\begin_inset Formula $(a_{1},a_{2},b,c)$
\end_inset

 instead of the clade 
\begin_inset Formula $((a_{1},a_{2})A,b_{1},b_{2})$
\end_inset

.
\end_layout

\begin_layout Section
Algorithmic approach
\end_layout

\begin_layout Standard
In order to make the supertree construction more tractable, we prune the
 taxonomy by removing tips that are not present in any input tree, on the
 theory that these tips cannot affect conflict resolution, and can easily
 be added-back after the supertree problem is solved.
\end_layout

\begin_layout Standard
We also take a divide-and-conquer approach by dividing the supertree into
 subproblems along edges of the taxonomy that are uncontested by any of
 the input trees.
 This approach therefore forces monophyly for these groups, which might
 (possibly?) be non-optimal.
 However, the downsides of this approach seem minimal, compared to the improveme
nt in scalability.
 We thus divide the supertree problem into 
\begin_inset Quotes eld
\end_inset

subproblems
\begin_inset Quotes erd
\end_inset

, and apply our solver to each subproblem.
\end_layout

\begin_layout Standard
---
\end_layout

\begin_layout Standard
Presenting an easy-to-interpret summary of trees that have been “curated”
 is one component of that effort.
 We seek to find a summary tree that
\end_layout

\begin_layout Enumerate

\series bold
minimizes 
\series default
the amount of computer memory and processing time required to construct
 the summary.
\end_layout

\begin_layout Enumerate

\series bold
maximizes
\series default
 the number of splits in input trees that it displays.
 
\end_layout

\begin_layout Enumerate
(?)
\series bold
 minimize
\series default
 the number of conflicts between the summary tree and the input trees (?)
\end_layout

\begin_layout Enumerate

\series bold
has no unsupported branches:
\series default
 each non-terminal branch is supported by an input tree.
\end_layout

\begin_layout Enumerate

\series bold
has no unnecessary polytomies:
\series default
 polytomies should remain in the supertree only if unresolvable by any of
 the input trees.
\end_layout

\begin_layout Standard
The point of maximizing the number of displayed groups from input trees,
 and having no unsupported branches, is not to construct an estimate of
 the true tree, but to explain and represent the input trees well.
 Thus, the tree should be interpreted as a summary.
 Here a non-terminal branch is 
\begin_inset Quotes eld
\end_inset

supported
\begin_inset Quotes erd
\end_inset

 by a phylogenetic input if contracting that branch stops displaying a split
 from that phylogenetic input.
 
\end_layout

\begin_layout Section
Algorithmic approach
\end_layout

\begin_layout Standard
We also make the following tactical choices
\end_layout

\begin_layout Enumerate

\series bold
conflict
\series default
 is resolved by ranking the input trees; splits from higher ranked trees
 over-rule conflicting splits from lower-ranked trees, unless the split
 from the higher-ranked tree is itself over-ruled by a split from an even
 high ranked tree.
\end_layout

\begin_layout Enumerate
a 
\series bold
taxonomy-based supertree
\series default
.
 This is a novel name for a special form of the supertree problem.
 A taxonomy-based supertree has at least one input (the taxonomic tree)
 which is complete.
 the taxonomy is considered the lowest-ranked input.
\end_layout

\begin_layout Standard
In order to achieve these goals, we have made the following algorithmic
 choices:
\end_layout

\begin_layout Subsection
Problem decomposition
\end_layout

\begin_layout Standard
First, all branches in the taxonomy that are not contested by any of the
 input trees are automatically accepted into the summary tree.
 Given these branches, the supertree problem may then be decomposed into
 smaller problems delimited by the uncontested taxonomy branches as boundaries.
 Each sub-problem is characterized by a ranked sequence of subtrees that
 are derived from regions of phylogenetic inputs that fall between the boundarie
s.
 The smaller problems size then makes tractable a variety of strategies
 to solve the sub-problems, and decreases the amount of computer memory
 and processing time that is required.
 
\end_layout

\begin_layout Subsection
Subproblem solution
\end_layout

\begin_layout Standard
Second, when solving sub-problems, we sequentially incorporate splits from
 trees in order of ranking, retaining splits that are compatible with the
 current set of splits.
 The order of splits from the same tree is not specified by this approach,
 and we incorporate splits in post-order.
 We make use of the BUILD algorithm to assess compatibility.
 This strategy avoids unnecessary polytomies, since splits of later input
 trees are only rejected from the summary supertree if they conflict with
 higher-priority splits.
 Finally, we use the BUILD algorithm to construct a supertree displaying
 all of the splits in the set of compatible splits.
 Using the BUILD algorithm to construct the subproblem summary tree satisfies
 criterion 3, because trees from the BUILD algorithm do not contain unsupported
 branches.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require An ordered list of $M$ splits, $
\backslash
mathcal{R} = [R_1, R_2, R_3, 
\backslash
ldots, R3, 
\backslash
ldots, R_M]$
\end_layout

\begin_layout Plain Layout


\backslash
State $
\backslash
mathcal{C} = [R_1]$
\end_layout

\begin_layout Plain Layout


\backslash
For{each split $i$ in $[2, 3 
\backslash
ldots M]$}
\end_layout

\begin_layout Plain Layout

   
\backslash
State $
\backslash
mathcal{T} 
\backslash
leftarrow 
\backslash
mathcal{C} + R_i$ 
\backslash
Comment{where `+' means concatenating 2 lists}
\end_layout

\begin_layout Plain Layout

   
\backslash
If{
\backslash
textsc{BUILD}$(
\backslash
mathcal{T})$ does not return null}
\end_layout

\begin_layout Plain Layout

      
\backslash
State $
\backslash
mathcal{C} 
\backslash
leftarrow 
\backslash
mathcal{T}$
\end_layout

\begin_layout Plain Layout

   
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor{}
\end_layout

\begin_layout Plain Layout


\backslash
State
\backslash
Return $
\backslash
mathcal{C}$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ConsistentSplitsFromRankedList"

\end_inset

ConsistentSplitsFromRankedList
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Pipeline
\end_layout

\begin_layout Standard
In order to achieve these criteria, we have 
\end_layout

\begin_layout Enumerate
Start with ranked list of trees
\end_layout

\begin_layout Enumerate
Check out phylo inputs from phylesystem
\end_layout

\begin_layout Enumerate
Make phylo input snapshot (e.g.
 pinned version of phylo inputs)
\end_layout

\begin_layout Enumerate
clean taxonomy & clean phylo inputs (in parallel)
\end_layout

\begin_layout Enumerate
Replace non-terminals with exemplars
\end_layout

\begin_layout Enumerate
Decompose into subproblems
\end_layout

\begin_layout Enumerate
Solve subproblems
\end_layout

\begin_layout Enumerate
Regraft subproblems
\end_layout

\begin_layout Enumerate
Unprune the solution
\end_layout

\begin_layout Enumerate
Label the solution
\end_layout

\begin_layout Enumerate
Generate annotations
\end_layout

\begin_layout Standard
import READMEs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pipeline-tools.png
	height 75pheight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Data flow through the 
\emph on
propinquity
\emph default
 pipeline.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithms
\end_layout

\begin_layout Standard
For the sub-problem solver, we make iterative use of the BUILD algorithm.
 We process input trees in order of their priority.
 We use the BUILD algorithm to determine whether a given split in an input
 tree is consistent with the splits we have kept so far.
 If the new split is consistent, then we add it to the set.
 After considering all input trees, and the taxonomy, we use the BUILD algorithm
 to construct a tree from the set of consistent splits.
\end_layout

\begin_layout Itemize
Add algorithm from TEX document.
\end_layout

\begin_layout Section
Example
\end_layout

\begin_layout Standard
We should have a small example: taxonomy and a couple of trees.
 I guess the example should illustrate the idea of uncontested decomposition?
 Maybe about 8 taxa, 1 contested node, 1 uncontested node?
\end_layout

\begin_layout Standard
We could also have an example thats 
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
We have decreased the time to construct a supertree from (?) about 24 hours
 to about 8 minutes (minus pickle-creation time).
 The amount of RAM required to construct the supertree has decreased from
 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $Y$
\end_inset

.
 
\end_layout

\begin_layout Standard
Compared to the previous pipeline, we have
\end_layout

\begin_layout Itemize
no unsupported nodes
\end_layout

\begin_layout Itemize
no unresolved polytomies
\end_layout

\begin_layout Standard
We also increase the number of displayed input splits from 35439 to 39713,
 which is an increase of 3774 more nodes displayed, a 10.6% increase.
 The number of input splits that do not conflict with the summary tree,
 but are not incorporated drops from 2736 to 0.
 The number of input splits that conflict with the phylogeny drops from
 2850 to 1312, a decrease of 1538, or 54.0%.
\end_layout

\begin_layout Standard
Additionally, our pipeline now produces a tree with annotations about which
 input trees support each node in the summary tree.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
One of our aim in supertree construction is to minimize the amount of informatio
n in the supertree that does not come from any of the input trees.
 However this general principle can be formalized in a variety of ways.
 For example, one approach is to minimize the number of nodes in the supertree
 while representing as many of the input splits as possible.
 While initially attractive, this approach has the downside that, when it
 is given two input trees with disjoint taxa, it will attempt to merge these
 trees into a single tree in order to decrease the number of nodes.
 For example, if given the tree ((human,gorilla),(dog,cat)) and the tree
 ((fugu,tuna),(shark,ray)) the minimum node criterion leads to the supertree
 ((human,gorilla,fugu,tuna),(dog,cat,shark,ray)) or ((human,gorilla,shark,ray),(
dog,cat,fugu,tuna)) with 3 internal nodes.
 In constrast, the BUILD algorithm would produce ((human,gorilla),(dog,cat),(fug
u,tuna),(shark,ray)) with 5 internal nodes.
 We thus prefer the BUILD algorithm, with its preference not to merge groups
 unless there is phylogenetic input supporting the merger.
\end_layout

\begin_layout Paragraph*
comparison with other supertree approaches
\end_layout

\begin_layout Standard
distance-based: what supertree approaches are distance-based?
\end_layout

\begin_layout Standard
maximum number of input triplets
\end_layout

\begin_layout Paragraph*
guarantees
\end_layout

\begin_layout Itemize
may not display a rooted triplet that is supported and uncontested, if that
 triplet is contested by a 
\emph on
combination
\emph default
 of other rooted triplets.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "otcetera"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
