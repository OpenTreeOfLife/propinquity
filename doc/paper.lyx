#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\begin_preamble
\usepackage{algorithm,algpseudocode}
\usepackage{lmodern}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\taxonomy}{\mbox{\mathbb{T}}}
{\mbox{\mathbb{T}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\prunedTaxonomy}{\taxonomy_{P}}
{\taxonomy_{P}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\phyloinputs}{\mathcal{T}}
{\mathcal{T}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\expandedPhylo}{\phyloinputs_{E}}
{\phyloinputs_{E}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\summaryTree}{\mathbb{S}}
{\mathbb{S}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\prunedSummary}{\summaryTree_{P}}
{\summaryTree_{P}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\collections}{\mathcal{C}}
{\mathcal{C}}
\end_inset


\end_layout

\begin_layout Title
A supertree pipeline for summarizing phylogenetic and taxonomic information
 for millions of species
\end_layout

\begin_layout Author
Benjamin D.
 Redelings
\begin_inset Formula $^{1,2}$
\end_inset

, Mark T.
 Holder
\begin_inset Formula $^{1,3}$
\end_inset


\end_layout

\begin_layout Abstract
We present a new supertree method and software implementation that enables
 rapid estimation of a summary tree on the scale of millions of leaves.
 This software pipeline is called 
\emph on

\begin_inset Quotes eld
\end_inset

propinquity.
\begin_inset Quotes erd
\end_inset


\emph default
 It uses the dependency-tracking tool 
\begin_inset Quotes eld
\end_inset


\emph on
make
\emph default

\begin_inset Quotes erd
\end_inset

 to direct the series of operations required to construct the tree.
 It relies heavily on 
\emph on
otcetera
\emph default
 - a set of C++ tools to performs most of the steps of the pipeline.
 All of the components are free software and are available on GitHub.
 This pipeline is currently used by the Open Tree of Life project to produce
 version 5 of that project's 
\begin_inset Quotes eld
\end_inset

synthetic tree
\begin_inset Quotes erd
\end_inset

.
 The propinquity-based pipeline improves on previous supertree construction
 methods because it produces no unsupported branches, and it avoids unnecessary
 polytomies.
 In addition to producing a tree, the pipeline writes an annotations file
 that reports which grouping in the input trees support each of the groups
 in the supertree.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Open Tree of Life project seeks to build a platform for summarizing
 what is known about phylogenetic relationships across all of Life 
\begin_inset CommandInset citation
LatexCommand citep
key "HinchliffEtAl2015"

\end_inset

.
 One primary goal of the project is to build a summary tree from a comprehensive
 taxonomic tree and a set of published trees.
 The summary tree is intended to transparently and justifiably represent
 phylogenetic information from these inputs.
 The taxonomic tree is derived from the Open Tree Taxonomy (OTT hereafter,
 publication in preparation).
 The phylogenetic inputs are published trees that have been curated to align
 the tips to OTT and to identify the correct rooting (see 
\begin_inset CommandInset citation
LatexCommand citealt
key "McTavishEtAt2015"

\end_inset

 for further details); these trees do not include all leaf taxa.
 The inputs (taxonomy and phylogenetic trees) and the output summary supertree
 are all rooted.
 Here we describe the software pipeline (
\emph on
propinquity
\emph default
) that summarizes and integrates these smaller source trees and the taxonomy
 tree into a single supertree and the noteworthy tools for manipulating
 and solving supertrees in the 
\emph on
otcetera
\emph default
 package.
\end_layout

\begin_layout Subsection
Goals
\end_layout

\begin_layout Standard
Translating the goals of the Open Tree of Life's summary tree into an explicit
 set of criteria is not trivial.
 The summary supertree should represent the phylogenetic information from
 source trees in a transparent and justifiable fashion.
 We would like to allow users to correct errors in the supertree by improving
 the input information rather than requiring modifyication to the supertree
 algorithm.
 The pipeline was designed to create a tree which:
\end_layout

\begin_layout Enumerate
displays no unsupported groups,
\end_layout

\begin_layout Enumerate
defers to groupings from higher ranked trees in the case of conflict, 
\end_layout

\begin_layout Enumerate
contains no unnecessary polytomies, and
\end_layout

\begin_layout Enumerate
displays as many groupings from input trees as possible.
\end_layout

\begin_layout Standard
These goals are described more fully below.
 In order to accomplish transparency and justification, our pipeline also
 produces annotations files with information about conflict and support.
 
\end_layout

\begin_layout Subsubsection
Goal 1: Each grouping is supported by at least one input
\end_layout

\begin_layout Standard
We require that each edge in the supertree be supported by at least one
 input tree edge.
 In addition to aiding interpretability, this requirement keeps the supertree
 from arbitrarily representing information that comes from none of the input
 trees.
 Of course, in a supertree analysis, the full tree will imply some relationships
 for subsets of the taxa that are not found in any input tree.
 So, the meaning of 
\begin_inset Quotes eld
\end_inset

supported by
\begin_inset Quotes erd
\end_inset

 needs some clarification.
 
\end_layout

\begin_layout Paragraph*
Notation, terminology, and the definition of 
\begin_inset Quotes eld
\end_inset

supported by
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\summaryTree$
\end_inset

 denote a supertree, and 
\begin_inset Formula $T_{i}$
\end_inset

 denote the 
\begin_inset Formula $i$
\end_inset

th input tree.
 The set of taxa that are mapped to the tips of the tree 
\begin_inset Formula $T_{i}$
\end_inset

 is 
\begin_inset Formula $\mathcal{L}(i)$
\end_inset

.
 
\begin_inset Formula $\summaryTree(i)$
\end_inset

 denotes the summary tree induced by tip nodes that are mapped to taxa in
 
\begin_inset Formula $\mathcal{L}(i)$
\end_inset

 and the most recent common ancestor of those leaves, and any other node
 that is an ancestor of some but not all of these leaves.
 We say that edge 
\begin_inset Formula $j$
\end_inset

 of the supertree is compatible with an input tree, 
\begin_inset Formula $T_{i}$
\end_inset

 if edge 
\begin_inset Formula $j$
\end_inset

 either is not included in the induced tree 
\begin_inset Formula $\summaryTree(i)$
\end_inset

 or none of the edges in 
\begin_inset Formula $T_{i}$
\end_inset

 are in conflict with edge 
\begin_inset Formula $j$
\end_inset

 in the induced tree.
 
\end_layout

\begin_layout Standard
We can consider whether or not an node in an input tree is displayed by
 
\begin_inset Formula $\summaryTree$
\end_inset

.
 For any such node 
\begin_inset Formula $j$
\end_inset

 there is a set of taxa that are mapped to the tips that descend from the
 node.
 This set of taxa can be denoted 
\begin_inset Formula $\mathcal{L}(i,j)$
\end_inset

 and will be referred to as the 
\begin_inset Quotes eld
\end_inset

include set
\begin_inset Quotes erd
\end_inset

 of the node.
 The 
\begin_inset Quotes eld
\end_inset

exclude set
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

 is the set of taxa in 
\begin_inset Formula $\mathcal{L}(i)$
\end_inset

 but not in 
\begin_inset Formula $\mathcal{L}(i,j)$
\end_inset

.
 If the set of tip-mapped taxa for any node in 
\begin_inset Formula $\summaryTree(i)$
\end_inset

 is identical to 
\begin_inset Formula $\mathcal{L}(i,j)$
\end_inset

, then we say that 
\begin_inset Formula $\summaryTree$
\end_inset

 displays node 
\begin_inset Formula $j$
\end_inset

 of 
\begin_inset Formula $T_{i}$
\end_inset

.
 We say that the summary tree 
\emph on
displays
\emph default
 edge 
\begin_inset Formula $j$
\end_inset

 if the summary tree displays the child node of edge 
\begin_inset Formula $j$
\end_inset

.
 Operationally, we can find the most recent common ancestor (MRCA) node
 of 
\begin_inset Formula $\mathcal{L}(i,j)$
\end_inset

 in 
\begin_inset Formula $\summaryTree$
\end_inset

; the summary tree displays 
\begin_inset Formula $j$
\end_inset

 if and only if that MRCA node is not an ancestor of any member of the exclude
 set of 
\begin_inset Formula $j$
\end_inset

.
 We say that edge 
\begin_inset Formula $k$
\end_inset

 of the summary tree is 
\emph on
supported by
\emph default
 node 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

 if the summary tree displays node 
\begin_inset Formula $j$
\end_inset

, but if we contracted edge 
\begin_inset Formula $k$
\end_inset

 then the modified summary tree would no longer display node 
\begin_inset Formula $k$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We can consider whether or not an edge in an input tree is displayed by
 the summary tree.
 Each edge 
\begin_inset Formula $\boldsymbol{e}=(e_{1,}e_{2})$
\end_inset

 in any tree 
\begin_inset Formula $t$
\end_inset

 goes from 
\begin_inset Formula $e_{1}$
\end_inset

 to 
\begin_inset Formula $e_{2}$
\end_inset

, where 
\begin_inset Formula $e_{1}$
\end_inset

 is the rootward node.
 Let 
\begin_inset Formula $\taxonomy$
\end_inset

 denote a taxonomy tree, let 
\begin_inset Formula $\summaryTree$
\end_inset

 denote a supertree, and 
\begin_inset Formula $T_{i}$
\end_inset

 denote the 
\begin_inset Formula $i$
\end_inset

th input tree.
 Every node 
\begin_inset Formula $k$
\end_inset

 in the taxonomy tree denotes a taxon, and every leaf node of 
\begin_inset Formula $\summaryTree$
\end_inset

 and 
\begin_inset Formula $T_{i}$
\end_inset

 correspond to a taxon.
 In addition some, but not all of internal nodes of 
\begin_inset Formula $\summaryTree$
\end_inset

 correspond to a taxon.
 The set of taxa that are mapped to the tips of a tree 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $\mathcal{L}(t)$
\end_inset

, and the set of taxa that are mapped to tips that descend from a node 
\begin_inset Formula $n$
\end_inset

 is 
\begin_inset Formula $\mathcal{L}(n)$
\end_inset

.
 We assocate the edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 with its tipward node 
\begin_inset Formula $e_{2}$
\end_inset

 and define 
\begin_inset Formula $\mathcal{L}(\boldsymbol{e})$
\end_inset

 to be the tip taxa 
\begin_inset Formula $\mathcal{L}(e_{2})$
\end_inset

 that are on the tipward side of 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
We can consider the information content of an edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 in a tree 
\begin_inset Formula $t$
\end_inset

 in terms of the split 
\begin_inset Formula $\sigma(\boldsymbol{e})$
\end_inset

 associated with that edge.
 Each edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 in tree 
\begin_inset Formula $t$
\end_inset

 divides tip taxa into two groups when cut.
 The group 
\begin_inset Formula $\mathcal{L}(\boldsymbol{e})$
\end_inset

 that are on the tipward side of 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 will be referred to as the 
\begin_inset Quotes eld
\end_inset

include set
\begin_inset Quotes erd
\end_inset

 of the edge.
 The rest of the taxa in are referred to as the 
\begin_inset Quotes eld
\end_inset

exclude set
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

.
 The split 
\begin_inset Formula $\sigma(\boldsymbol{e})$
\end_inset

 represents the division of the include group from the exclude group by
 the edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

, and we write
\begin_inset Formula 
\begin{align*}
\sigma(\boldsymbol{e}) & =\sigma_{1}(e)|\bullet\sigma_{2}(e)\\
 & =\mathcal{L}(\boldsymbol{e})|\bullet\mathcal{L}(t)-\mathcal{L}(\boldsymbol{e}).
\end{align*}

\end_inset

The symbol 
\begin_inset Formula $\bullet$
\end_inset

 represents the root node and indicates that the root is on the same side
 of 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 as the exclude set.
 
\end_layout

\begin_layout Plain Layout
Compatibility for a group of splits means that it is possible for all splits
 to occur on edges of a single tree.
 Two rooted splits 
\begin_inset Formula $\boldsymbol{\alpha}=\alpha_{1}|\bullet\alpha_{2}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\beta}=\beta_{1}|\bullet\beta_{2}$
\end_inset

 are pairwise compatible if at least one of 
\begin_inset Formula $\alpha_{1}\cap\beta_{1}$
\end_inset

 or 
\begin_inset Formula $\alpha_{1}\cap\beta_{2}$
\end_inset

 or 
\begin_inset Formula $\alpha_{2}\cap\beta_{1}$
\end_inset

 are empty, and incompatible otherwise.
 This is true even if the total taxon set of 
\begin_inset Formula $\boldsymbol{\alpha}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\beta}$
\end_inset

 are different, which might occur if 
\begin_inset Formula $\boldsymbol{\alpha}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\beta}$
\end_inset

 are splits on edge of different trees.
 For two splits 
\begin_inset Formula $\boldsymbol{\alpha}$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\beta}$
\end_inset

 we say that 
\begin_inset Formula $\boldsymbol{\alpha}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

implies
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\boldsymbol{\beta}$
\end_inset

 if 
\begin_inset Formula $\beta_{1}\subseteq\alpha_{1}$
\end_inset

 and 
\begin_inset Formula $\beta_{2}\subseteq\alpha_{2}$
\end_inset

.
 Likewise, for some leaf set 
\begin_inset Formula $L$
\end_inset

 we use 
\begin_inset Formula $\alpha|_{L}$
\end_inset

 to indicate the restriction of 
\begin_inset Formula $\alpha$
\end_inset

 to 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\alpha_{L} & =\alpha_{1}\cap L|\bullet\alpha_{2}\cap L.
\end{align*}

\end_inset

We say that edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 of the supertree is compatible with an input tree 
\begin_inset Formula $T_{i}$
\end_inset

 if the split 
\begin_inset Formula $\sigma(\boldsymbol{e})|_{\mathcal{L}(T_{i})}$
\end_inset

 is compatible with the split 
\begin_inset Formula $\sigma(\boldsymbol{f})$
\end_inset

 induced by each edge 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

 of 
\begin_inset Formula $T_{i}$
\end_inset

.
 In this case, compatibility with each edge implies separately implies joint
 compatibility will all edges of 
\begin_inset Formula $T_{i}$
\end_inset

, so that 
\begin_inset Formula $T_{i}$
\end_inset

 either contains 
\begin_inset Formula $\sigma(\boldsymbol{e})|_{\mathcal{L}(T_{i})}$
\end_inset

 or can be extended to contain such an edge.
\end_layout

\begin_layout Plain Layout
If the 
\begin_inset Formula $\sigma(\boldsymbol{e})$
\end_inset

 implies 
\begin_inset Formula $\sigma(\boldsymbol{f})$
\end_inset

 for any edge 
\begin_inset Formula $\boldsymbol{e}\in\summaryTree$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{f}\in T_{i}$
\end_inset

 then we say that 
\begin_inset Formula $\summaryTree$
\end_inset

 displays edge 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

 of 
\begin_inset Formula $T_{i}$
\end_inset

.
 We say that edge 
\series bold
e
\series default
 of the summary tree is supported by 
\series bold

\begin_inset Formula $\boldsymbol{f}$
\end_inset


\series default
 in 
\begin_inset Formula $T_{i}$
\end_inset

 if the summary tree displays 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

, but if we contracted edge 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

 then the resulting tree would no longer display 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

.
 Operationally, we can find the most recent common ancestor (MRCA) node
 in the summary tree for the include set of 
\series bold

\begin_inset Formula $\boldsymbol{f}$
\end_inset


\series default
; the summary tree displays 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

 if and only if that MRCA node is not an ancestor of any member of the exclude
 set of 
\begin_inset Formula $\boldsymbol{f}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that stating that a node in the summary tree is supported by an input
 does not imply that every descendant of that node must be present in the
 input nor that every taxon that is not a descendant must be excluded in
 order to display the node.
 Consider the problem shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:toyambig"

\end_inset

; panels (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:toyambig"

\end_inset

a) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:toyambig"

\end_inset

b) show 2 input trees.
 Because taxa A and E do not occur together in either input, there is some
 uncertainty about where to place them.
 By our terminology, either output shown in (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:toyambig"

\end_inset

c) or (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:toyambig"

\end_inset

d) would be characterized as a tree that displays all of the input groupings
 and which has no unsupported groups.
 Clearly these criteria are insufficient to specify a unique solution, and
 users of the output tree need to be aware that it may be possible for some
 taxa to 
\begin_inset Quotes eld
\end_inset

float
\begin_inset Quotes erd
\end_inset

 to multiple positions.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our current method of solving subproblems (BUILD) places each 
\begin_inset Quotes eld
\end_inset

floating
\begin_inset Quotes erd
\end_inset

 subtree as close to the root as possible.
 However, when reattaching taxonomy-only subtrees, we do not do this.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_ambig/abcd.svg
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_ambig/bcde.svg
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_ambig/soln1.svg
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_ambig/soln2.svg
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An example demonstrating that our definition of 
\begin_inset Quotes eld
\end_inset

supported by
\begin_inset Quotes erd
\end_inset

 does not imply entire composition of a grouping.
 (a) and (b) show 2 input trees and (c) and (d) depict trees that each display
 each of the groupings in the input trees and which have no unsupported
 nodes.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:toyambig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of our aims in supertree construction is to minimize the amount of informati
on in the supertree that does not come from input trees.
 We permit information that comes from combinations of input trees, but
 not any single input tree.
 However, we seek to exclude information that comes from none of the input
 trees.
 This motivates the criterion of not having any unsupported edges, since
 these edges could be removed without decreasing the support from any input
 tree.
\end_layout

\begin_layout Subsubsection
Goal 2: Tree ranking
\end_layout

\begin_layout Standard
An appealing goal for the summarization would be to find the supertree that
 displays the largest number of input tree edges.
 Despite being easy to state, this formulation does not provide biologists
 who use the summarization tool with an obvious avenue for fixing perceived
 problems with the summary tree.
 For example, a grouping that a biologist expected may not be present in
 the supertree, but it may not conflict with any of the input groupings
 which are displayed.
 This can happen because displaying both node 
\begin_inset Formula $a$
\end_inset

 from 
\begin_inset Formula $T_{1}$
\end_inset

 and node 
\begin_inset Formula $b$
\end_inset

 from tree 
\begin_inset Formula $T_{2}$
\end_inset

 in a summary tree may only be possible by displaying a grouping that is
 present in no input tree.
 All other factors being equal, if this implied grouping conflicts with
 input node 
\begin_inset Formula $c$
\end_inset

 in tree 
\begin_inset Formula $T_{3}$
\end_inset

, then 
\begin_inset Formula $c$
\end_inset

 will not be displayed in the summary tree, but a biologist will not necessarily
 know how to fix this problem.
 One solution is to use a ranking of groupings.
 If an expert were quite confident in the 
\begin_inset Formula $x$
\end_inset

 grouping, then she could assign that input node a high ranking.
 A supertree that used ranks could then recover this grouping even if its
 inclusion did not increase the total number of input nodes that are displayed
 by the summary tree.
 Figure (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pairwisecompat"

\end_inset

) shows an example of 3 input trees for which there is no pairwise incompatibili
ty, but no solution displays all of the input groups.
 Alternative rankings of inputs can result in one of three summary trees
 shown in panels (d-f).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/abc.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Input Tree 1
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/acd.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Input Tree 2
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/bcd.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Input tree 3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/s12.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/s13.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/toy_pairwise_compat/s23.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An example of 3 input trees shown in (a), (b), and (c) which do not conflict
 in a pairwise manner, but cannot be jointly displayed in one tree.
 The 3 solution trees are shown in panels (d-f).
 Panel (d) for ranking the tree in (c) lowest.
 Panel (e) shows the solution if the tree in (b) has the lowest rank.
 Panel (f) shows the solution if the tree in (a) is ranked lowest.
 Each of the solutions displays 2 of the 3 input groupings.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pairwisecompat"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any approach to supertree construction must deal with the need to adjudicate
 between conflicting input trees.
 We choose to deal with conflict by ranking the input trees, and preferring
 to include edges from higher-ranked trees.
 The merits of using tree ranking are questionable because the system does
 not mediate conflicts based on the relative amount of evidence for each
 alternative.
 However, it is a reasonable starting point.
 It has the benefits of making it easy to see why some groups are included
 or not (transparency), and it allows simpler and cleaner algorithms.
\end_layout

\begin_layout Standard
Note that if an edge 
\begin_inset Formula $c$
\end_inset

 conflicts with a higher-ranked edge 
\begin_inset Formula $b$
\end_inset

, then 
\begin_inset Formula $c$
\end_inset

 may still be included in the supertree.
 This can occur when the higher ranked edge 
\begin_inset Formula $b$
\end_inset

 conflicts with a yet-higher ranked edge 
\begin_inset Formula $a$
\end_inset

, and thus 
\begin_inset Formula $b$
\end_inset

 is not included.
 In that case, it will be possible for 
\begin_inset Formula $c$
\end_inset

 to be represented in the summary tree.
 Thus, the fact that the summary tree displays an input edge does not imply
 that none of the higher ranked input trees conflict with that edge.
 
\end_layout

\begin_layout Standard
In order to produce a comprehensive supertree, we also require a rooted
 taxonomy tree in addition to the ranked list of rooted input trees.
 Unlike other input trees, the taxonomy tree is required to contain all
 taxa, and thus has the maximal leaf set.
 We make the taxonomy tree the lowest ranked tree.
 We refer to this the formulation as the 
\begin_inset Quotes eld
\end_inset

taxonomic supertree problem
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In our current formulation, the taxonomy tree is also unique in that the
 taxonomy is the only source of taxonomic names.
 Each node in the taxonomy tree corresponds to a named group.
 Taxonomic groups may have the same name, but each node in the taxonomy
 tree is identified by a unique number (its OTT Id).
 Taxonomic groups are identified in the summary supertree by finding a branch
 (or 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

) that has exactly the same include|exclude relationship.
 The taxonomy supertree can meaningfully possess degree-two nodes.
 Although these nodes can be removed without affecting the relationships
 of the leaves, they do represent nested taxonomic groups that contain exactly
 one subgroup.
 The taxonomy is also used to determine which tips are terminal taxa.
\end_layout

\begin_layout Subsubsection
Goal 3: Contain no unnecessary polytomies
\end_layout

\begin_layout Standard
The supertree should be as resolved as possible - in other words, it should
 have no unnecessary polytomies.
 Thus, for each input edge that is 
\emph on
not
\emph default
 included, we can point to a reason for non-inclusion by showing that the
 input edge conflicts with some node/edge of the summary tree.
 Note, that the requirement to not display unsupported groups leads to some
 
\begin_inset Quotes eld
\end_inset

necessary
\begin_inset Quotes erd
\end_inset

 polytomies.
 For example any resolution of the polytomy shown in figure (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pairwisecompat"

\end_inset

e) would continue to display the same 2 input groups, but the additional
 grouping would be unsupported, because the unresolved tree already displays
 the 2 input groups.
 Thus, the additional group would be unsupported and the unresolved tree
 would be preferred by our criterion.
 However, collapsing either internal edge of the tree shown in figure (
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pairwisecompat"

\end_inset

d) would result in tree which displays only one input grouping.
 This tree would contain an unnecessary polytomy, because the polytomy would
 permit refinement to the depicted tree which displays more input groupings.
\end_layout

\begin_layout Subsubsection
Goal 4: Display as many input nodes as feasible
\end_layout

\begin_layout Standard
We also seek to construct a supertree that represents as many input tree
 nodes as possible.
 Since non-included input tree nodes must conflict with the supertree (or
 they would have been added), this criterion is the same as minimizing the
 number of input nodes that conflict with the supertree.
\end_layout

\begin_layout Subsubsection
Summary of goals
\end_layout

\begin_layout Standard
These optimality criteria help to define what it means for the supertree
 to represent the input trees, as well as justifying and explaining why
 various features of the supertree exist.
 The pipeline described below produces a supertree that satisfies the first
 three optimality criteria and is a greedy approximation of a solution to
 the fourth goal.
 It is not guaranteed to display as many input nodes as possible.
 Even if the summary tree does accomplish goal 4, it is not necessarily
 a 
\emph on
unique
\emph default
 optimum.
 The pipeline takes a greedy approach to producing a summary tree by attempting
 to add groupings from the trees in order of the trees ranking.
 This can be viewed as a greedy solution to the problem of finding the tree
 with the maximum sum of displayed groups' weighted scores criterion (described
 in the appendix A) where the weights from the trees are so extreme that
 displaying one group from a highly ranked tree is preferred to displaying
 all of the groupings from lower ranked trees.
\end_layout

\begin_layout Section
Description of the propinquity pipeline
\end_layout

\begin_layout Subsection
Preprocessing steps
\end_layout

\begin_layout Standard
Propinquity was designed to function as a part of the Open Tree of Life
 software architecture, so the first few steps of the pipeline involve transform
ing artifacts from that project into a set of rooted trees and a phylogenetic
 taxonomy.
 The phylesystem API 
\begin_inset CommandInset citation
LatexCommand citep
key "McTavishEtAt2015"

\end_inset

 of Open Tree allows users to curate published estimates of trees and create
 ranked collections of these trees.
 Early steps in the propinquity pipeline manipulate the phylogenetic input
 trees to improve their usability and reliability.
 The first steps of the pipeline (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pipeline"

\end_inset

) collect a list of trees to include (in the 
\family typewriter
phylo_input
\family default
 subdirectory) and store copies of these files (in the 
\family typewriter
phylo_snapshot
\family default
 subdirectory) to make it easier to replicate the operation (because the
 collection of trees and the tree files change due to curation).
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pipeline-tools.png
	height 75pheight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Organization of the 
\emph on
propinquity
\emph default
 pipeline.
 Each pentagon labels a program (blue for otcetera-based tools and red for
 python scripts in the propinquity or peyotl repository) that performs the
 important operations in each step.
 The output of each step corresponds to a subdirectory of the propinquity
 system which will hold the output artifacts for the step.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:pipeline"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Pruning questionable taxa from the taxonomy
\end_layout

\begin_layout Standard
OTT is a hierarchy of taxonomic names that implies a phylogenetic taxonomy.
 An OTT ID has a position in the hierarchy, a taxonomic name, and set of
 references to the same name in different taxonomies.
 In addition, the ID may also be associated with a set of flags that can
 indicate that the taxon may be questionable.
 These flags can either encode information taken from an input taxonomy
 (for example, taxa the NCBI refers to as 
\begin_inset Quotes eld
\end_inset

unplaced
\begin_inset Quotes erd
\end_inset

 are assigned an 
\begin_inset Quotes eld
\end_inset

unplaced
\begin_inset Quotes erd
\end_inset

 flag) or can arise because of some form of conflict during taxonomy constructio
n (for example, if two taxonomies disagree on the name for a taxon, then
 the taxon will be merged and the name will be retained without any descendants;
 this name will have an OTT Id, but will be flagged as 
\begin_inset Quotes eld
\end_inset

barren
\begin_inset Quotes erd
\end_inset

).
 Propinquity prunes the OTT down to a more reliable taxonomy by pruning
 off parts of the tree that are flagged with suspicious flags.
 The set of flags that lead to a subtree of the taxonomy being pruned is
 under the control of the user (the set of flags used by the Open Tree of
 Life project can be found in the 
\family typewriter
config.opentree.synth
\family default
 file in the propinquity repository).
 For the purpose of the rest of the pipeline, an OTT Id that has been pruned
 from the taxonomy will be treated in the same way as invalid OTT Id.
 The output of this step is stored in propinquity's 
\family typewriter
cleaned_ott
\family default
 subdirectory; this operation only needs to be performed when the OTT or
 the pruning flags change.
\end_layout

\begin_layout Subsubsection
Pruning problematically mapped tips from input phylogenetic trees
\end_layout

\begin_layout Standard
Frequently, phylogenetic estimates are rooted using the outgroup criterion,
 which is an assumption about the monophyly of the ingroup taxa.
 Because the rooting of the branches in the outgroup portion of the tree
 is often uncertain, data curators can identify the ingroup node of the
 tree; propinquity uses this annotation to prune off the outgroup taxa.
\end_layout

\begin_layout Standard
Frequently, not all tips in a phylogenetic input will have been mapped to
 a taxon in the current version OTT.
 Unmapped leaves are pruned from each phylogenetic input.
 In some cases, the OTT has changed and a taxon has been unambiguously mapped
 to another taxon.
 This can occur when multiple species in one version of the taxonomy are
 
\begin_inset Quotes eld
\end_inset

lumped
\begin_inset Quotes erd
\end_inset

 into a single taxon in a subsequent version.
 OTT maintains a set of 
\begin_inset Quotes eld
\end_inset

forwarding
\begin_inset Quotes erd
\end_inset

 statements about IDs that have been removed but can be mapped to an existing
 taxon; propinquity uses these statements to update the OTU mapping of input
 trees.
\end_layout

\begin_layout Standard
Finally some leaves are mapped to taxa that occur more than once in the
 tree, or taxa that have ancestors represented as tips of the tree.
 In these cases, leaves are pruned to assure that tips are mapped to unique
 taxa that are not nested.
 In the case of nested taxa, the tip mapped to the higher level taxon is
 retained.
 In the case of duplicate occurrences of an OTT taxon, propinquity checks
 to see if a data curator has selected one of the taxa to be the exemplar
 for the taxon.
 If this selection has not been made, then the node with the lexicographically
 lowest ID is chosen to exemplify the taxon.
 This choice is arbitrary, but repeatable.
 The pruned phylogenetic inputs are stored in a 
\family typewriter
cleaned_phylo
\family default
 subdirectory of propinquity.
\end_layout

\begin_layout Subsubsection
Exemplifying tips mapped to higher taxa
\end_layout

\begin_layout Standard
Many input trees have tips that are not terminal taxa, but higher-order
 taxonomic groups.
 It is not clear how to interpret a tip in a phylogenetic estimate that
 is labeled with the name of a higher taxon.
 Several scenarios can lead to these cases: the data for the tip could have
 been created by merging a chimeric set of character scores from constituent
 taxa; the species sampled may not have been identified to the lowest taxonomic
 rank; or the researcher may simply have used a higher taxonomic name because
 he/she assumed that the taxon is monophyletic and the higher level name
 is more recognizable.
 Rather than allowing the ambiguity about interpretation of the higher-taxon
 mapped tips to propagate throughout the entire pipeline, we transform the
 input trees by replacing higher taxa at tips with a set of terminal-taxon
 exemplars for each taxon.
 One approach would be to simply determine all descendant terminal taxa
 and attach them as children of the problematic tip.
 However, this would create a clade rather than a tip; subsequent steps
 in the supertree would interpret the clade as a claim of monophyly for
 the taxon.
 The input tree may not have tested monophyly of the clade, so this interpretati
on is unwarranted.
 We avoid it by attaching exemplar taxa as child nodes of the higher taxonomic
 tip but then collapsing the edge between the node that connected the higher
 taxon to its parent.
 Thus, if 
\begin_inset Formula $A$
\end_inset

 is a non-terminal taxon containing terminal descendants 
\begin_inset Formula $a_{1}$
\end_inset

 and 
\begin_inset Formula $a_{2}$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is a non-terminal taxon containing terminal descendants 
\begin_inset Formula $b_{1}$
\end_inset

 and 
\begin_inset Formula $b_{2}$
\end_inset

 we would replace the subtree 
\begin_inset Formula $((A,B),c)$
\end_inset

 with 
\begin_inset Formula $((a_{1},a_{2},b_{1},b_{2}),c)$
\end_inset

 instead of the subtree 
\begin_inset Formula $(((a_{1},a_{2})A,(b_{1},b_{2})B),c)$
\end_inset

.
\end_layout

\begin_layout Standard
If a taxon is only present in the taxonomy (not in any of the input trees),
 then it can be pruned from the taxonomy for the construction of the supertree
 and then grafted back on to the summary tree later.
 Performing this pruning reduces the size of the supertree problem, reducing
 the running time of the pipeline.
 Similarly, when we expand a higher taxon in the exemplification step, we
 can omit members of the taxon if they do not occur in any of the phylogenetic
 inputs.
 If there are no members of the higher taxon sampled in any other input
 tree, then we arbitrarily choose one terminal taxon to represent the higher
 taxon.
 During the exemplification step, a tool from otcetera (
\family typewriter
otc-nonterminals-to-exemplars
\family default
) reads the taxonomy and all of the 
\begin_inset Quotes eld
\end_inset

cleaned
\begin_inset Quotes erd
\end_inset

 phylogenetic estimates from the previous step.
 Reading all of the inputs is necessary to assure that each higher taxon
 is replaced with the same set of exemplars regardless of which tree the
 higher taxon occurs in, and that the exemplars for a higher taxon is the
 union on the set of descendant terminal taxa that have been sampled in
 a phylogenetic input.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exemplify-example"

\end_inset

 shows an example of how the trees in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cleaned-phylo-example"

\end_inset

 would be exemplified.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/cleaned_phylo/ex_2@tree1.tre.svg
	scale 40
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree 1
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/cleaned_phylo/ex_2@tree2.tre.svg
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree 2
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/cleaned_ott/cleaned_ott.tre.svg
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Taxonomy Tree
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Input trees and taxonomy tree
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cleaned-phylo-example"

\end_inset


\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/exemplified_phylo/ex_2@tree1.tre.svg
	scale 40
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree 1
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/exemplified_phylo/ex_2@tree2.tre.svg
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree 2
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/exemplified_phylo/taxonomy.tre.svg
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pruned taxonomy tree 
\begin_inset Formula $\prunedTaxonomy$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Exemplified input trees and taxonomy tree from figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cleaned-phylo-example"

\end_inset

.
 E in tree1 is exemplified by E1.
 Pruned taxa are E2, F2, and D.
 The taxa E and F are retained as monotypic taxa in the pruned taxonomy
 
\begin_inset Formula $\prunedTaxonomy$
\end_inset

, but are not shown in panel c.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:exemplify-example"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Summary tree construction
\end_layout

\begin_layout Standard
After the preprocessing steps, the inputs have been converted to a set of
 rooted phylogenetic estimates in which each leaf is mapped to a terminal
 taxon in the exemplified taxonomic tree.
 The goal of the remainder of the pipeline is to construct a tree that maximizes
 the sum displayed groups' weighted scores criterion.
 This is accomplished in five steps: (1) reducing the tree size by pruning
 off tips not represented in any phylogenetic estimate; (2) dividing the
 full problem into subproblems based on uncontested taxa, (3) constructing
 a summary solution for each subproblem by greedily creating a maximally-sized
 list of groupings that can all be displayed simultaneously; (4) grafting
 the subproblem solutions into a single supertree; and (5) grafting (or
 
\begin_inset Quotes eld
\end_inset

unpruning
\begin_inset Quotes erd
\end_inset

) the taxonomy-only taxa onto the solution to produce a complete summary
 tree.
\end_layout

\begin_layout Subsubsection
Temporarily pruning leaves mapped to taxa found only in the taxonomy
\end_layout

\begin_layout Standard
We prune the taxonomy by removing tips that are not present in any input
 tree.
 The tips pruned in this step will be grafted back onto the skeleton of
 the summary tree in a subsequent step.
 A terminal taxon that is represented only in the taxonomy can be pruned
 and then regrafted onto the solution without affecting which nodes are
 displayed by the final summary tree.
 Thus, this procedure does not impede our ability to find a good summary
 tree.
 Removing these tips produces a smaller input to the rest of the pipeline,
 which reduces running times.
 
\end_layout

\begin_layout Standard
This step is actually performed by the 
\family typewriter
otc-nonterminals-to-exemplars
\family default
 tool that was mentioned in the last step of the pre-processing portion
 of the pipeline.
 After producing the set of 
\begin_inset Quotes eld
\end_inset

exemplified
\begin_inset Quotes erd
\end_inset

 phylogenetic inputs, this tool exports a pruned down version of the taxonomy
 that only contains tips that are present in at least one phylogenetic input.
 In version 5.0 of the Open Tree of Life synthetic tree, this version of
 the taxonomic tree contained only 41,226 leaves (while the flag-cleaned
 version of OTT had 2,424,255 leaves).
\end_layout

\begin_layout Subsubsection
Subproblem decomposition
\end_layout

\begin_layout Standard
For the sake of efficiency, propinquity uses a divide-and-conquer approach
 to construct the supertree.
 Subproblems are identified by searching through the taxonomy tree to find
 any taxa are not contested by any single input tree.
 Here we say that input tree 
\begin_inset Formula $T_{i}$
\end_inset

 contests taxon 
\begin_inset Formula $x$
\end_inset

 in the pruned taxonomy, if 
\begin_inset Formula $x$
\end_inset

 is not monophyletic in any resolution of tree 
\begin_inset Formula $T_{i}$
\end_inset

.
 Thus, polytomies in an input tree are treated as soft polytomies, and a
 taxon is not contested merely because it is not displayed by an input tree.
 
\end_layout

\begin_layout Standard
This operation is performed by the 
\family typewriter
otc-uncontested-decompose
\family default
 tool in otcetera; see appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Decompose-algorithm"

\end_inset

 for a description of the algorithm.
 The output is a series of subproblems, each of which corresponds to a slice
 of the taxonomy and corresponding slices through each relevant input tree.
 Each uncontested non-terminal and non-root taxon will show up in two subproblem
s: it will be the root of its own subproblem and it will be tip in the subproble
m that covers the next slice deeper in the tree.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:detect-uncontested-example"

\end_inset

 highlights the taxa that are not contested by the input shown in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exemplify-example"

\end_inset

; figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subproblems-example"

\end_inset

 shows the subproblems that would be emitted as a result of this set of
 inputs.
 The supertree operation of 
\begin_inset CommandInset citation
LatexCommand citet
key "HinchliffEtAl2015"

\end_inset

 also used this otcetera-based decomposition step.
\end_layout

\begin_layout Standard
Note that decomposition into uncontested groups does not necessarily allow
 us to find the tree that maximizes the MSDGWS score.
 For example, see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:decompose-worsens"

\end_inset

; that example is a variant of the situation shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pairwisecompat"

\end_inset

.
 In this case the groupings from each of the phylogenetic estimates, shown
 in panels (a) and (b), could be displayed.
 That solution is shown in panel (d), it displays 2 of the 3 input splits,
 but is optimal because no solution displays all 3 input groupings and the
 depicted solution displays the 2 highest ranked groupings.
 However, neither of the trees shown in panels (a) or (b) contest the taxon
 
\begin_inset Formula $B$
\end_inset

 shown in the taxonomy panel (c).
 Thus, when using our decomposition, the branches leading to taxa 
\begin_inset Formula $B1$
\end_inset

 and 
\begin_inset Formula $B2$
\end_inset

 in the input phylogenetic trees would be sliced during the decomposition,
 and relabeled to refer to taxon 
\begin_inset Formula $B$
\end_inset

.
 This taxonomically-informed interpretation of the inputs views the two
 phylogenetic inputs as in conflict; so the solution returned by propinquity
 would defer to the higher ranked tree.
 The tree shown in panel (e) would be returned.
 This example arises from the fact that the trees in (a) and (b) jointly
 contest taxon 
\begin_inset Formula $B$
\end_inset

, but neither contests taxon 
\begin_inset Formula $B$
\end_inset

 when the trees are considered in isolation.
\end_layout

\begin_layout Standard
Despite the fact that the use of 
\family typewriter
otc-uncontested-decompose
\family default
 can worsen the final score of the summary tree, we use this approach in
 propinquity because it makes the construction of the tree faster and it
 is easy for users to correct issues caused by incorrect taxa being constrained
 to be monophyletic.
 By adding a tree (even a low-ranked tree) that contests a taxon to the
 corpus of input trees , then the next synthetic tree will no longer consider
 the taxon to be uncontested.
 Thus the procedure encourages curation of more phylogenetic inputs as a
 means of improving the summary tree.
 
\end_layout

\begin_layout Standard
In version 5.0 of the summary tree, this decomposition procedure produced
 5,545 subproblems, but only 1,586 of these were non-trivial to solve.
 If a subproblem contains only two tips it is trivial; 2,443 subproblems
 were trivial in this way.
 Similarly, if a subproblem contains only 2 trees it is trivial to solve
 because the solution will simply be all of the groupings from the first
 tree combined with all of the groupings from the second tree that are compatibl
e with the first tree; 2,838 subproblems were trivial in this way.
 The subproblem with the largest number of tips contained 953 tips.
 The largest subproblem, in terms of the number of input trees (including
 the taxonomic tree) that were relevant, had 18 trees.
 Without decomposition, the supertree problem would have had 512 input trees
 and 41,226 leaves.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/exemplified_phylo_taxonomy_uncontested.tre.svg
	width 35text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Uncontested edges from the inputs shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exemplify-example"

\end_inset

.
 Here the taxon 
\emph on
ABCD
\emph default
 is uncontested.
 The edge to the ABCD node is colored red.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:detect-uncontested-example"

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/subproblems/14/1.tre.svg
	width 30text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Figures/subproblems/14/2.tre.svg
	width 30text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Figures/subproblems/14/3.tre.svg
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Subproblem 
\emph on
ABCD
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/subproblems/17/1.tre.svg
	width 30text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Figures/subproblems/17/2.tre.svg
	width 30text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename Figures/subproblems/17/3.tre.svg
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Subproblem 
\emph on
root
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Subproblems generated from the exemplified trees shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exemplify-example"

\end_inset

.
 A trivial statemen from the first tree that a taxon labelled 
\begin_inset Formula $ABCD$
\end_inset

 is sister to 
\begin_inset Formula $E$
\end_inset

 has been omitted, because trees with only 2 leaves do not contain phylogenetic
 information.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:subproblems-example"

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/uncontested_worsens_score/ab1c.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/uncontested_worsens_score/acb2.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/uncontested_worsens_score/tax.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/uncontested_worsens_score/opt.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/uncontested_worsens_score/returned.svg
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
An example with three input trees: the highest ranked phylogenetic input
 panel (a), the second ranked phylogenetic input (b), and the taxonomy in
 panel (c).
 The summary tree in panel (d) has the highest possible score, but the summary
 shown in panel (e) would be returned from the pipeline that uses uncontested
 taxon decomposition.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:decompose-worsens"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Presenting an easy-to-interpret summary of trees that have been “curated”
 is one component of that effort.
 We seek to find a summary tree that
\end_layout

\begin_layout Enumerate

\series bold
minimizes 
\series default
the amount of computer memory and processing time required to construct
 the summary.
\end_layout

\begin_layout Enumerate

\series bold
maximizes
\series default
 the number of splits in input trees that it displays.
 
\end_layout

\begin_layout Enumerate
(?)
\series bold
 minimize
\series default
 the number of conflicts between the summary tree and the input trees (?)
\end_layout

\begin_layout Enumerate

\series bold
has no unsupported branches:
\series default
 each non-terminal branch is supported by an input tree.
\end_layout

\begin_layout Enumerate

\series bold
has no unnecessary polytomies:
\series default
 polytomies should remain in the supertree only if unresolvable by any of
 the input trees.
\end_layout

\begin_layout Plain Layout
The point of maximizing the number of displayed groups from input trees,
 and having no unsupported branches, is not to construct an estimate of
 the true tree, but to explain and represent the input trees well.
 Thus, the tree should be interpreted as a summary.
 Here a non-terminal branch is 
\begin_inset Quotes eld
\end_inset

supported
\begin_inset Quotes erd
\end_inset

 by a phylogenetic input if contracting that branch stops displaying a split
 from that phylogenetic input.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Subproblem solution
\end_layout

\begin_layout Standard
When solving sub-problems, we sequentially incorporate splits from trees
 in order of ranking, retaining splits that are compatible with the current
 set of splits (Alg 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ConsistentSplitsFromRankedList"

\end_inset

).
 The order of splits from the same tree is not specified by this approach,
 and we incorporate splits using one of the possible post-order traversals
 of the tree.
 We make use of the BUILD algorithm 
\begin_inset CommandInset citation
LatexCommand citep
key "AhoSSU1981"

\end_inset

 to assess compatibility.
 This strategy avoids unnecessary polytomies, since splits of later input
 trees are only rejected from the summary supertree if they conflict with
 higher-priority splits.
 Finally, we use the BUILD algorithm to construct a supertree displaying
 all of the splits in the set of compatible splits.
 Using the BUILD algorithm to construct the subproblem summary tree satisfies
 criterion 3, because trees from the BUILD algorithm do not contain unsupported
 branches.
 
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\begin_layout Plain Layout


\backslash
Require An ordered list of $M$ splits, $
\backslash
mathcal{R} = [R_1, R_2, R_3, 
\backslash
ldots, R3, 
\backslash
ldots, R_M]$
\end_layout

\begin_layout Plain Layout


\backslash
State $
\backslash
mathcal{C} = [R_1]$
\end_layout

\begin_layout Plain Layout


\backslash
For{each split $i$ in $[2, 3 
\backslash
ldots M]$}
\end_layout

\begin_layout Plain Layout

   
\backslash
State $
\backslash
mathcal{T} 
\backslash
leftarrow 
\backslash
mathcal{C} + R_i$ 
\backslash
Comment{where `+' means concatenating 2 lists}
\end_layout

\begin_layout Plain Layout

   
\backslash
If{
\backslash
textsc{BUILD}$(
\backslash
mathcal{T})$ does not return null}
\end_layout

\begin_layout Plain Layout

      
\backslash
State $
\backslash
mathcal{C} 
\backslash
leftarrow 
\backslash
mathcal{T}$
\end_layout

\begin_layout Plain Layout

   
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor{}
\end_layout

\begin_layout Plain Layout


\backslash
State
\backslash
Return $
\backslash
mathcal{C}$
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ConsistentSplitsFromRankedList"

\end_inset

ConsistentSplitsFromRankedList
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The BUILD algorithm as originally stated by 
\begin_inset CommandInset citation
LatexCommand citet
key "AhoSSU1981"

\end_inset

 applies to a collection of rooted triplets.
 Instead of decomposing each input split into a collection of rooted triplets,
 we instead modify the BUILD algorithm to apply directly to larger rooted
 splits.
 The modified BUILD algorithm constructs a tree compatible with a collection
 of rooted splits, and returns failure if such a tree does not exist.
 This modified algorithm recovers the original BUILD algorithm if only rooted
 triplets are supplied as input.
 When larger splits are supplied as input, the results are the same as if
 each was was decomposed into all implied triplets.
 The modified build algorithm has order 
\begin_inset Formula $O(N^{2}+N^{2}E+NL)$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the number of splits passed in, 
\begin_inset Formula $E$
\end_inset

 is the average size of the exclude group, and 
\begin_inset Formula $L$
\end_inset

 is the total number of leaves.
 This simplifies to 
\begin_inset Formula $O(N^{2})$
\end_inset

 if all splits are triplets.
 In this approach splits are either entirely retained or entirely discarded
 - consistent rooted triplets from conflicting splits are not retained.
 However, when unpruning taxonomy-only taxa (see below), we make an attempt
 to break ties in a way that preserves some partial information from conflicting
 splits by attaching taxa from conflicting splits at their common ancestor.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subproblem-solutions."

\end_inset

 shows the solutions that would be obtained by applying our modified version
 of the BUILD algorithm to the subproblems show in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subproblems-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/subproblem_solutions/ott14.tre.svg
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solution to subproblem 
\emph on
ABCD
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/subproblem_solutions/ott17.tre.svg
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solution to subproblem 
\emph on
root
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Solutions to the subproblems depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subproblems-example"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:subproblem-solutions."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Solution grafting
\end_layout

\begin_layout Standard
To produce a tree that spans all of the taxa sampled in the exemplified
 set of input trees, we graft the subproblem solutions into a single tree
 (stored as the 
\family typewriter
grafted_solution/grafted_solution.tre
\family default
 by propinquity).
 Recall that each non-root uncontested taxon used for decomposition occurs
 as a leaf taxon in one subproblem and as a root taxon in one other subproblem.
 Thus, the grafting operation simply consists of reading all of the subproblem
 solutions into memory and then merging the nodes that are labeled with
 the same OTT ID.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/grafted_solution/grafted_solution_ottnames.tre.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Grafted solution.
 The nodes E and F are monotypic here, but will end up being polytypic after
 unpruning is performed.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Unpruning unsampled taxa
\end_layout

\begin_layout Standard
As described above, taxa that do not have any descendants in a sampled phylogene
tic input are pruned from the taxonomy for the sake of efficiency.
 These taxa are reattached by an 
\begin_inset Quotes eld
\end_inset

unpruning step.
\begin_inset Quotes erd
\end_inset

 For those taxa that are compatible with the grafted tree, this step simply
 amounts to adding any unsampled taxonomic children to the node that represents
 the taxon in the grafted solution tree.
\end_layout

\begin_layout Standard
However, a taxon may be incompatible with the grafted solution; we refer
 to such taxa as 
\begin_inset Quotes eld
\end_inset

broken taxa.
\begin_inset Quotes erd
\end_inset

 If a broken taxon contains some unsampled children, it is not clear where
 these unsampled children should be attached to the grafted solution.
 One approach would be to mimic the application of apply Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ConsistentSplitsFromRankedList"

\end_inset

 to the full (unpruned) taxonomic tree.
 This would be equivalent to collapsing each edge in the taxonomy that attaches
 a broken taxon to its parent.
 The unsampled children of broken taxa would attach at their least inclusive
 ancestral taxon which is unbroken.
 In cases of several adjacent taxa are broken, this can lead to polytomies
 of very high degree deep in the tree.
 This can make the summary tree difficult to navigate.
 Thus, we have adopted an alternative solution.
 The 
\family typewriter
otc-unprune-solution-and-name-unnamed-nodes
\family default
 tool from otcetera attaches the unsampled children of a broken taxa to
 the grafted solution as children of the MRCA of the sampled children.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Two-approaches-to-unpruning"

\end_inset

 illustrates the two approaches to unpruning.
 Taxa G, M, and R (Fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Two-approaches-to-unpruning"

\end_inset

a) are broken because they conflict with the grafted solution (Fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Two-approaches-to-unpruning"

\end_inset

b); among these, only taxon R has children that were unsampled in the grafted
 solution.
 Ignoring all broken taxa when unpruning would cause the unsampled children
 (R4, R5, and R6) to attached directly at taxon N (as in the tree shown
 in Fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Two-approaches-to-unpruning"

\end_inset

c), because that is the least inclusive unbroken ancestor of R.
 The tree illustrated in Fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Two-approaches-to-unpruning"

\end_inset

d shows the tree that would be produced by propinquity; the children of
 the broken taxon R and instead attached at the MRCA of sampled children
 (R1, R2, and R3).
 Their attachment point does not correspond to a taxon in the taxonomic
 tree.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename example3/cleaned_ott-labels.tre.pdf
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Taxonomy
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename example3/grafted_solution-labels.tre.pdf
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Grafted solution
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename example3/unprune-old-labels.tre.pdf
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unpruned tree - broken taxa removed
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename example3/unprune-new-labels2.tre.pdf
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unpruned tree with MRCA-attachment
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Two-approaches-to-unpruning"

\end_inset

Two approaches to unpruning.
 Taxa G and R in the taxonomy (a) are broken because they conflict with
 the grafted solution (b).
 Removing these broken taxa from the taxonomy before unpruning leads to
 taxa R4, R5, and R6 being attached directly at taxon N, as in tree (c).
 In tree (d), the children of the broken taxon R and instead attached at
 the MRCA of R1, R2, and R3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/labelled_supertree/labelled_supertree_only_taxon_names.tre.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unpruned tree with internal taxa.
 Nodes E2, F2, and D have been re-added to the tree.
 The nodes E and F are no longer monotypic.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Naming unnamed nodes
\end_layout

\begin_layout Standard
In order to annotate each node in the summary supertree, it is first necessary
 that each node have a unique identifier.
 Nodes whose include group correspond exactly to the include group of a
 node in the taxonomy are given the same identifier as the corresponding
 taxonomy node.
 These identifier are of the form 
\begin_inset Formula $ottX$
\end_inset

 where 
\begin_inset Formula $X$
\end_inset

 is an integer OTT id.
 We generate a label of the form 
\begin_inset Formula $mrcaottX_{1}ottX_{2}$
\end_inset

 for an non-taxonomic node 
\begin_inset Formula $n$
\end_inset

 where 
\begin_inset Formula $X_{1}$
\end_inset

 and 
\begin_inset Formula $X_{2}$
\end_inset

 are the OTT ids for two leaves, 
\begin_inset Formula $n$
\end_inset

 is the MRCA of these leaves, and 
\begin_inset Formula $X_{1}$
\end_inset

 and 
\begin_inset Formula $X_{2}$
\end_inset

 are the smallest numbers that can be chosen to designate 
\begin_inset Formula $n$
\end_inset

 as their MRCA.
 Because new taxa added to OTT will be given higher OTT Ids, the use of
 the lowest numbered OTT Ids as designators increases the chance that a
 node label can be encountered in a subsequent version of the tree (though
 the taxonomic content may change).
 The deterministic choice of designators also makes the labeling insensitive
 to branch rotation of the grafted solution tree.
\end_layout

\begin_layout Subsubsection
Annotation
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Support for each node in the tree.
 How do we show this?
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Annotations 
\end_layout

\begin_layout Standard
To reveal the connections between the groupings found in the a summary supertree
 and the input trees, propinquity uses a few Python scripts and the 
\family typewriter
otc-annotate-synth
\family default
 tool from otcetera to create an annotations file describing the pipeline
 used and the connections between phylogenetic information in the inputs
 and the summary.
 The JSON file produced by 
\family typewriter
otc-annotate-synth
\family default
 encodes a 
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

 property that holds a mapping between a node name for the summary tree
 (using the naming convention described in the previous section) and a node
 provenance object categorizes the relationship between the node and the
 inputs.
 The node provenance object for node 
\begin_inset Formula $x$
\end_inset

 uses several properties to categorize the relationship between the node
 and the inputs; each property in the node provenance object maps to a structure
 storing the tree ID and node IDs for the input tree nodes.
 
\end_layout

\begin_layout Standard
Conceptually, this annotation operation in equivalent to considering every
 node 
\begin_inset Formula $j$
\end_inset

 in each input tree 
\begin_inset Formula $i$
\end_inset

 and the summary tree node 
\begin_inset Formula $x$
\end_inset

.
 Because the vast majority of nodes in the input studies will be compatible
 but not directly relevant to node 
\begin_inset Formula $x$
\end_inset

 we do not list all of the compatible groupings.
 If node 
\begin_inset Formula $x$
\end_inset

 is not included in the induced tree 
\begin_inset Formula $\mathcal{\mathbb{S}}(i)$
\end_inset

, then none of the nodes of tree 
\begin_inset Formula $i$
\end_inset

 will be referred to in the annotations for node 
\begin_inset Formula $x$
\end_inset

.
 Even if 
\begin_inset Formula $x$
\end_inset

 is included in 
\begin_inset Formula $\mathcal{\mathbb{S}}(i)$
\end_inset

, many of the nodes of 
\begin_inset Formula $T_{i}$
\end_inset

 will be compatible with 
\begin_inset Formula $x$
\end_inset

 while being relevant to other parts of the summary tree.
 The only input nodes listed for node 
\begin_inset Formula $x$
\end_inset

 are with rooted taxon bipartitions which conflict with, are displayed by,
 or are resolved by the the rooted taxonomic bipartition associated with
 node 
\begin_inset Formula $x$
\end_inset

.
 All input nodes that cannot be displayed by any supertree that contains
 
\begin_inset Formula $x$
\end_inset

 are stored in a 
\begin_inset Quotes eld
\end_inset

conflicts_with
\begin_inset Quotes erd
\end_inset

 property of the node provenance object.
 If node 
\begin_inset Formula $j$
\end_inset

 of 
\begin_inset Formula $T_{i}$
\end_inset

 is displayed by the summary tree and 
\begin_inset Formula $x$
\end_inset

 is part of the path of 
\begin_inset Formula $\mathcal{\mathbb{S}}(i)$
\end_inset

 that displays the split between descendants of 
\begin_inset Formula $j$
\end_inset

 and other taxa, then a reference to the node 
\begin_inset Formula $j$
\end_inset

 will be in the node provenance object.
 The exact categorization of this annotation will depend on the configuration
 of node 
\begin_inset Formula $x$
\end_inset

 on the induce tree 
\begin_inset Formula $\mathcal{\mathbb{S}}(i)$
\end_inset

:
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $x$
\end_inset

 is a terminal path in the induced tree then node 
\begin_inset Formula $j$
\end_inset

 will be listed in the 
\begin_inset Quotes eld
\end_inset

terminal
\begin_inset Quotes erd
\end_inset

 property;
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $x$
\end_inset

 is along an internal path that contains some nodes with out-degree equal
 to 1, then node 
\begin_inset Formula $j$
\end_inset

 will be listed in the 
\begin_inset Quotes eld
\end_inset

partial_path_of
\begin_inset Quotes erd
\end_inset

 property; and
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $x$
\end_inset

 is along an internal path that contains without any node of out-degree
 1, then node 
\begin_inset Formula $j$
\end_inset

 will be listed in the 
\begin_inset Quotes eld
\end_inset

supported_by
\begin_inset Quotes erd
\end_inset

 property, because node 
\begin_inset Formula $j$
\end_inset

 supports the existence of grouping 
\begin_inset Formula $x$
\end_inset

 in the sense that collapsing the edge that separates 
\begin_inset Formula $x$
\end_inset

 from its parent would cause the summary tree to no longer display node
 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Standard
Finally, if 
\begin_inset Formula $T_{i}$
\end_inset

 does not display 
\begin_inset Formula $x$
\end_inset

 from 
\begin_inset Formula $\mathcal{\mathbb{S}}(i)$
\end_inset

, but there exists an unresolved node 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

 which could be resolved such that the tree would then display 
\begin_inset Formula $x$
\end_inset

, then a reference to node 
\begin_inset Formula $j$
\end_inset

 will be listed in the 
\begin_inset Quotes eld
\end_inset

resolves
\begin_inset Quotes erd
\end_inset

 property of node 
\begin_inset Formula $x$
\end_inset

.
 
\end_layout

\begin_layout Standard
The otcetera annotation tool can also detect cases in which including informatio
n from node 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $T_{i}$
\end_inset

 could further resolve a polytomy 
\begin_inset Formula $x$
\end_inset

 in the summary tree; such a case would be annotated using the 
\begin_inset Quotes eld
\end_inset

resolved_by
\begin_inset Quotes erd
\end_inset

 property of 
\begin_inset Formula $x$
\end_inset

.
 However, because of our goal of excluding unnecessary polytomies, none
 of the nodes in propinquity's summary tree will use this annotation when
 they are annotated with the set of input trees.
\end_layout

\begin_layout Subsubsection
Self-documentation
\end_layout

\begin_layout Standard
An optional step in the propinquity pipeline (triggered by the executing
 the 
\begin_inset Quotes eld
\end_inset

make html
\begin_inset Quotes erd
\end_inset

 target) can compose an index.html file for each directory created during
 the pipeline to explain the artifacts held in that directory and report
 summary statistics about the summarization run.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
Here we have described the motivation and methodology used by the propinquity
 tool that is currently used by the Open Tree of Life project to build its
 summary tree.
 A modified version of the treemachine software which built the summary
 tree described in the 
\begin_inset CommandInset citation
LatexCommand citet
key "HinchliffEtAl2015"

\end_inset

 paper is used by the project to serve the tree produced by propinquity
 via Open Tree of Life APIs.
 The migration of summary tree construction from treemachine (used for version
 4) to propinquity (for all versions from v5.0 to present) has decreased
 the computational time required to construct a supertree from several hours
 to about 8 minutes (after some preprocessing steps which only have to be
 performed when the input taxonomy changes).
 The amount of RAM required during tree construction has also decreased
 substantially.
 Unlike the previous tree, the tree from propinquity contained no unsupported
 nodes or unnecessary polytomies.
 The number of displayed input splits from increased from 35,439 (for version
 4) to 39,713; a 10.6% increase.
 The number of input splits that do not conflict with the summary tree,
 but are not incorporated drops from 2736 to 0.
 The number of input splits that conflict with the phylogeny drops from
 2850 to 1312, a decrease of 1538, or 54.0%.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
ARE THESE numbers for the same set of inputs? or v4 to v5 (the latter had
 the barnacles tree collection, and perhaps a few other tree differences?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
Thanks to Karen Cranston, Jonathan Rees, Jim Allman, Cody Hinchliff, Stephen
 Smith, and Joseph Brown for discussions and feedback.
 Thanks to NSF grant 1208393 (DEB), part of the collaborative Open Tree
 of Life awards, the University of Kansas, and the Heidelberg Institute
 for Theoretical Studies for funding.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "otcetera"
options "upmplainnat"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
\begin_inset CommandInset label
LatexCommand label
name "sec:The-maximum-sum"

\end_inset

The maximum sum displayed groups' weighted scores criterion
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\mathcal{W}$
\end_inset

 is a weighting function that maps any input tree's internal node to a non-negat
ive number.
 If 
\begin_inset Formula $I(\mathbb{S},i,j)$
\end_inset

 is an indicator function that is 1 if summary tree 
\begin_inset Formula $\mathbb{S}$
\end_inset

 displays the node 
\begin_inset Formula $V(i,j)$
\end_inset

 and 0 otherwise then: 
\begin_inset Formula $SDGWS(\mathbb{S})=\sum_{i}\sum_{j}I(\mathbb{S},i,j)\mathcal{W}(i,j)$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

sum of displayed groups' weighted scores
\begin_inset Quotes erd
\end_inset

 for a tree where 
\begin_inset Formula $i$
\end_inset

 indexes all of the input trees and 
\begin_inset Formula $j$
\end_inset

 indexes each non-root internal node in tree 
\begin_inset Formula $i$
\end_inset

.
 Preference for this tree is referred to as the maximum sum displayed groups'
 weighted scores criterion (MSDGWS criterion).
 The summary tree constructed by the propinquity pipeline is a greedy heuristic
 for finding a tree that maximizes this score when the weights for a node
 are determined by the tree's weight and the difference in weighting is
 so large that displaying one node from a highly ranked tree is preferred
 to displaying all of the nodes in the trees with lower rank.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Decompose-algorithm"

\end_inset

Description of the decomposition algorithm of otc-uncontested-decompose
\end_layout

\begin_layout Standard
The input is the a ranked list of input trees and comprehensive taxonomy.
 
\end_layout

\begin_layout Subsection
Creation of multigraph of the taxonomy with embedded trees
\end_layout

\begin_layout Standard
The tool creates a multigraph by starting with a graph is isomorphic to
 the taxonomic tree.
 The nodes and edges created in this step will be referred to as the 
\begin_inset Quotes eld
\end_inset

taxonomic graph.
\begin_inset Quotes erd
\end_inset

 Next, we add nodes and edges to that graph in a procedure that we refer
 to as 
\begin_inset Quotes eld
\end_inset

embedding
\begin_inset Quotes erd
\end_inset

 the input trees into the taxonomy.
 A node is introduced for each node in an input tree, and these nodes are
 mapped the MRCA nodes in the taxonomic graph.
 In other words, for any node 
\begin_inset Formula $y$
\end_inset

 in an input tree with a set of descendants, 
\begin_inset Formula $\mathcal{C},$
\end_inset

 we find the most tipward node 
\begin_inset Formula $z$
\end_inset

 in the taxonomic graph that is an ancestor to all of the taxa in 
\begin_inset Formula $\mathcal{C}$
\end_inset

; let 
\begin_inset Formula $m(y)=z$
\end_inset

 refer to this mapping, and 
\begin_inset Formula $m^{\prime}(z)=y$
\end_inset

 refer to the reverse mapping.
 Each edge 
\begin_inset Formula $e_{ij}$
\end_inset

 in a source tree 
\begin_inset Formula $i$
\end_inset

 connects ancestor to its descendant, 
\begin_inset Formula $a(e_{ij})\rightarrow d(e_{ij})$
\end_inset

.
 The edges are introduced into the graph.
 We also introduce new edges to create a from 
\begin_inset Formula $m(a(e_{ij}))$
\end_inset

 through its descendants to 
\begin_inset Formula $m(d(e_{ij}))$
\end_inset

; we denote this path 
\begin_inset Formula $p(e_{ij})$
\end_inset

 and refer to the edges in the path as 
\begin_inset Quotes eld
\end_inset

embedding edges for tree 
\begin_inset Formula $i$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Note, that this is a path through the taxonomic nodes, while the edge 
\begin_inset Formula $e_{ij}$
\end_inset

 connects source tree nodes.
 The mapping between 
\begin_inset Formula $e_{ij}$
\end_inset

 and 
\begin_inset Formula $p(e_{ij})$
\end_inset

 is stored, and the edges are labelled with the index 
\begin_inset Formula $i$
\end_inset

 so that it is clear which tree created them.
 Because the taxonomic tree is highly unresolved, it is frequently the case
 that 
\begin_inset Formula $m(a(e_{ij}))$
\end_inset

 is the same node as 
\begin_inset Formula $m(d(e_{ij}))$
\end_inset

; in these cases the embedding edge is a loop.
 This situation occurs whenever edge 
\begin_inset Formula $e_{ij}$
\end_inset

 can resolve part of the polytomy represented by a taxon.
 
\end_layout

\begin_layout Standard
We treat the taxonomy as the lowest ranked input tree.
 The next step will collapse contested edges in the taxonomic graph.
 To retain all of the information from the taxonomy we embed the taxonomy
 into the taxonomic graph as if it were another input tree
\end_layout

\begin_layout Subsection
Detection of uncontested higher taxa
\end_layout

\begin_layout Standard
After every input tree and the taxonomy tree have been embedded into the
 taxonomic graph, we perform postorder traversal over the taxonomic graph
 that underlies the multi-graph.
 For any internal node (each of which corresponds to a non-terminal taxon)
 we determine whether or not it is contested by examining each input tree.
 We can determine tree 
\begin_inset Formula $i$
\end_inset

 contests the taxon represented by taxonomic node 
\begin_inset Formula $x$
\end_inset

 by looking at the parents of all of the 
\begin_inset Quotes eld
\end_inset

exiting
\begin_inset Quotes erd
\end_inset

 embedding edges for tree 
\begin_inset Formula $i$
\end_inset

.
 These are the set of embedding edges that have 
\begin_inset Formula $x$
\end_inset

 as a daughter and have a parent node that is not 
\begin_inset Formula $x$
\end_inset

 (ergo a parent node that is taxonomically higher than 
\begin_inset Formula $x$
\end_inset

).
 If there are more than one parent nodes in this set of exiting embedding
 edges, then tree 
\begin_inset Formula $i$
\end_inset

 contests that taxon.
 If there is only parent node, then the all of the constituent taxa belonging
 to this taxon that are present in tree 
\begin_inset Formula $i$
\end_inset

 have one parent that is more inclusive; this means that the input tree
 does not contest monophyly of the taxon.
\end_layout

\begin_layout Standard
If the taxon is uncontested, then it may be the case that some input trees
 do not contest the taxon, but contain polytomies that could be resolved
 to display the taxon.
 The cases can be identified by finding multiple exiting embedding edges
 that have the same taxon 
\begin_inset Formula $y$
\end_inset

 as their parent node.
 In these cases, a pseudo input tree node is created and becomes the parent
 node for these edges; this new node is then connected to 
\begin_inset Formula $y$
\end_inset

 as if it had been an input edge.
 This operation is equivalent to resolving an input tree's polytomy in favor
 of the monophyly of the uncontested taxon.
 This is the only way in which the input trees are modified during the decomposi
tion.
\end_layout

\begin_layout Subsection
Collapsing contested taxa from the taxonomic graph
\end_layout

\begin_layout Standard
If a taxonomic node 
\begin_inset Formula $x$
\end_inset

 fails the 
\begin_inset Quotes eld
\end_inset

uncontested
\begin_inset Quotes erd
\end_inset

 test described in the previous section, then the node corresponding to
 the taxon is removed from the taxonomic graph and the set of edges (and
 mappings between input edges and embedded paths) is updated as if this
 taxon had not been present in when the taxonomic graph was created.
 This consists of detecting changing any edge in an embedding path that
 is adjacent to 
\begin_inset Formula $x$
\end_inset

 by replacing the reference to 
\begin_inset Formula $x$
\end_inset

 with a reference to its parent 
\begin_inset Formula $a(x)$
\end_inset

.
 Note that we do not collapse the edge corresponding to this taxon in the
 part of the graph that represents the embedding of the taxonomy into the
 taxonomic graph.
 Thus, the taxonomy will still claim the monophyly of the taxon.
 This is relevant if the input grouping that contests taxon 
\begin_inset Formula $x$
\end_inset

 is overruled (in the subproblem solution step) by a higher ranked split.
 In other words, the fact that the a taxon is contested during the decomposition
 is not a guarantee that the taxon will not be monophyletic in the final
 supertree.
\end_layout

\begin_layout Subsection
Emitting subproblems
\end_layout

\begin_layout Standard
Whenever an uncontested taxon is identified, the appropriate slice of each
 input trees that intersect with the taxon is written to a file.
 Then the multigraph is simplified by slicing any off the taxon.
 This slicing is accomplished by examing all of the exiting embedding edges
 for the taxon.
 The descendant taxa of each input tree is relabeled with the identifier
 of the contested taxa and all of that node's descendants are removed.
 Thus this input node will act as as if it were a leaf mapped to the uncontested
 taxon.
 All descendants of the taxonomic graph are also pruned off.
\end_layout

\end_body
\end_document
